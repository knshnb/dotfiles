{
    "CalcDepth.hpp": {
        "prefix": "CalcDepth",
        "body": "template <class T> std::vector<Int> calc_depth(const std::vector<std::vector<T>>& g, Int root) {\n    std::vector<Int> depth(g.size());\n    auto dfs = [&](auto&& self, Int v, Int prv = -1) -> void {\n        for (Int s : g[v]) {\n            if (s == prv) continue;\n            depth[s] = depth[v] + 1;\n            self(self, s, v);\n        }\n    };\n    dfs(dfs, root);\n    return depth;\n}\n",
        "description": "CalcDepth"
    },
    "DominatorTree.hpp": {
        "prefix": "DominatorTree",
        "body": "// https://knshnb.github.io/competitive_library/library/src/Graph/DominatorTree.hpp.html\n// に移行しました",
        "description": "DominatorTree"
    },
    "TwoEdgeConnectedComponents.hpp": {
        "prefix": "TwoEdgeConnectedComponents",
        "body": "/// @docs src/Graph/TwoEdgeConnectedComponents.md\nstruct TwoEdgeConnectedComponents {\n    int n;\n    std::vector<std::vector<int>> g;\n    std::vector<std::pair<int, int>> bridges;  // 列挙された橋\n    std::vector<int> belong_to;                // 各頂点の属する二重辺連結成分のindex\n    int size = -1;                             // 二重辺連結成分の個数\n\n    TwoEdgeConnectedComponents(int n_) : n(n_), g(n_) {}\n    TwoEdgeConnectedComponents(const std::vector<std::vector<int>>& g_) : n(g_.size()), g(g_) {}\n    void build() {\n        // dfs木を作り、各辺が後退辺にはさまれているかどうかをimos法で判定\n        std::vector<int> imos(n);  // imos[i] == 0なら(i, par)が橋になるように更新\n        std::vector<int> flag(n);  // 0: unvisited, 1: ancestor of current v, 2: done(後退辺になりえない)\n        auto dfs1 = [&](auto f, int v, int prv) -> void {\n            flag[v] = 1;\n            bool skipped_parent = false;\n            for (int s : g[v]) {\n                if (s == prv && !skipped_parent) {  // 多重辺に対応\n                    skipped_parent = true;\n                    continue;\n                }\n                if (flag[s] == 0) {\n                    f(f, s, v);\n                    if (imos[s] == 0) bridges.push_back({v, s});\n                    imos[v] += imos[s];\n                } else if (flag[s] == 1) {  // 後退辺\n                    imos[v]++;\n                    imos[s]--;\n                }\n            }\n            flag[v] = 2;\n        };\n        for (int i = 0; i < n; i++) {\n            if (flag[i] == 0) dfs1(dfs1, i, -1);\n        }\n\n        // 橋(imos[i] == 0となるような(i, par))で区切って二重編連結成分に分ける\n        int cur_group = 0;\n        belong_to.assign(n, -1);\n        auto dfs2 = [&](auto f, int v) -> void {\n            for (int s : g[v]) {\n                if (belong_to[s] != -1) continue;\n                belong_to[s] = imos[s] == 0 ? cur_group++ : belong_to[v];\n                f(f, s);\n            }\n        };\n        for (int i = 0; i < n; i++) {\n            if (belong_to[i] == -1) {\n                belong_to[i] = cur_group++;\n                dfs2(dfs2, i);\n            }\n        }\n        size = cur_group;\n    }\n};\n",
        "description": "TwoEdgeConnectedComponents"
    },
    "WarshallFloyd.hpp": {
        "prefix": "WarshallFloyd",
        "body": "/// @docs src/Graph/WarshallFloyd.md\ntemplate <class T> void warshall_floyd(std::vector<std::vector<T>> &d, const T INF) {\n    int n = d.size();\n    for (int i = 0; i < n; i++) assert(d[i][i] == 0);\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][k] == INF || d[k][j] == INF) continue;\n                d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n",
        "description": "WarshallFloyd"
    },
    "StronglyConnectedComponents.hpp": {
        "prefix": "StronglyConnectedComponents",
        "body": "/// @docs src/Graph/StronglyConnectedComponents.md\nstruct StronglyConnectedComponents {\n    int n, size;  // sizeはbuild()後に強連結成分の数を格納\n    std::vector<std::vector<int>> edge, redge;\n    std::vector<int> belong_to;\n    StronglyConnectedComponents(int n_) : n(n_), edge(n_), redge(n_) {}\n    void add_edge(int u, int v) {\n        assert(0 <= u && u < n && 0 <= v && v < n);\n        edge[u].push_back(v);\n        redge[v].push_back(u);\n    }\n    void build() {\n        std::vector<int> ord;  // post-order\n        // 正方向の辺でdfs、post-orderをふる\n        std::vector<bool> visited(n, false);\n        auto dfs1 = [&](auto f, int v) -> void {\n            if (visited[v]) return;\n            visited[v] = true;\n            for (int s : edge[v]) {\n                f(f, s);\n            }\n            ord.push_back(v);\n        };\n        for (int i = 0; i < n; i++) dfs1(dfs1, i);\n\n        // post-order逆順にdfs、到達可能な同値類に分ける\n        belong_to.assign(n, -1);\n        int cur_group = 0;\n        auto dfs2 = [&](auto f, int v) -> void {\n            if (belong_to[v] != -1) return;\n            belong_to[v] = cur_group;\n            for (int s : redge[v]) {\n                f(f, s);\n            }\n        };\n        std::reverse(ord.begin(), ord.end());\n        for (int i : ord) {\n            if (belong_to[i] == -1) {\n                dfs2(dfs2, i);\n                cur_group++;\n            }\n        }\n        size = cur_group;\n    }\n    bool has_loop() {\n        build();\n        return size < n;\n    }\n};\n",
        "description": "StronglyConnectedComponents"
    },
    "LowestCommonAncestor.hpp": {
        "prefix": "LowestCommonAncestor",
        "body": "// edgeを貼ったあとにbuild()を忘れない！\nstruct TreeDoubling {\n    struct Edge {\n        int to, len;\n    };  // 場合に応じて書き換える、toは必須\n    std::vector<std::vector<Edge>> g;\n    int n, size;  // MSB + 1\n    int root;\n    std::vector<int> depth;\n    std::vector<std::vector<int>> parent;  // ダミー頂点n(親もn)\n    TreeDoubling(int n_) : g(n_), n(n_), size(64 - __builtin_clzll(n_) + 1), depth(n_) {\n        parent.resize(size, std::vector<int>(n + 1, n));\n    }\n    void build(int root_ = 0) {\n        auto dfs = [&](auto f, int v, int prv) -> void {\n            for (Edge& e : g[v]) {\n                if (e.to == prv) continue;\n                depth[e.to] = depth[v] + e.len;\n                parent[0][e.to] = v;\n                f(f, e.to, v);\n            }\n        };\n        root = root_;\n        depth[root] = 0;\n        dfs(dfs, root, -1);\n        for (int k = 0; k < size - 1; k++) {\n            for (int i = 0; i < n; i++) {\n                parent[k + 1][i] = parent[k][parent[k][i]];\n            }\n        }\n    }\n\n    // vからd個分親にさかのぼった頂点、rootよりも上はnを返す\n    int query(int v, int d) {\n        int ret = v;\n        for (int j = 0; j < size; j++) {\n            if (d >> j & 1) ret = parent[j][ret];\n        }\n        return ret;\n    }\n    int lca(int u, int v) {\n        if (depth[u] > depth[v]) std::swap(u, v);\n        v = query(v, depth[v] - depth[u]);\n        if (u == v) return u;\n\n        for (int j = size - 1; j >= 0; j--) {\n            if (parent[j][u] == parent[j][v]) continue;\n            u = parent[j][u];\n            v = parent[j][v];\n        }\n        assert(parent[0][u] == parent[0][v]);\n        return parent[0][u];\n    }\n    int dist(int u, int v) { return depth[u] + depth[v] - depth[lca(u, v)] * 2; }\n};\n",
        "description": "LowestCommonAncestor"
    },
    "BellmanFord.hpp": {
        "prefix": "BellmanFord",
        "body": "// O(EV)、負のサイクルを通った後に到達できる点については-INF, 到達不可能な点についてはINFを返す\ntemplate <class T> struct BellmanFord {\n    struct Edge {\n        int from, to;\n        T cost;\n    };\n    const T INF = std::numeric_limits<T>::max() / 2;\n    int n;\n    std::vector<Edge> edges;\n\n    BellmanFord(int n_) : n(n_) {}\n    void add_edge(int u, int v, T cost) { edges.push_back({u, v, cost}); }\n    std::vector<T> run(int s) {\n        std::vector<T> dist(n, INF);\n        dist[s] = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (Edge& e : edges) {\n                if (dist[e.from] == INF) continue;\n                dist[e.to] = std::min(dist[e.to], dist[e.from] + e.cost);\n            }\n        }\n        for (Edge& e : edges) {\n            // sから到達できる負のサイクル検出\n            if (dist[e.to] < INF && dist[e.from] + e.cost < dist[e.to]) {\n                dist[e.from] = -INF;\n                dist[e.to] = -INF;\n            }\n        }\n        for (int i = 0; i < n - 1; i++) {\n            for (Edge& e : edges) {\n                if (dist[e.from] == -INF) dist[e.to] = -INF;\n            }\n        }\n        return dist;\n    }\n};\n",
        "description": "BellmanFord"
    },
    "TreeOrders.hpp": {
        "prefix": "TreeOrders",
        "body": "/// @docs src/Graph/TreeOrders.md\nstd::vector<int> pre_order(const std::vector<std::vector<int>>& g, int s = 0) {\n    std::vector<int> ord;\n    ord.reserve(g.size());\n    auto dfs = [&g, &ord](auto&& self, int v, int prv) -> void {\n        ord.push_back(v);\n        for (int s : g[v]) {\n            if (s == prv) continue;\n            self(self, s, v);\n        }\n    };\n    dfs(dfs, s, -1);\n    return ord;\n}\nstd::vector<int> post_order(const std::vector<std::vector<int>>& g, int s = 0) {\n    std::vector<int> ord;\n    ord.reserve(g.size());\n    auto dfs = [&g, &ord](auto&& self, int v, int prv) -> void {\n        for (int s : g[v]) {\n            if (s == prv) continue;\n            self(self, s, v);\n        }\n        ord.push_back(v);\n    };\n    dfs(dfs, s, -1);\n    return ord;\n}\n",
        "description": "TreeOrders"
    },
    "Dijkstra.hpp": {
        "prefix": "Dijkstra",
        "body": "template <class T, bool directed = true> struct Dijkstra {\n    struct Edge {\n        int to;\n        T cost;\n    };\n    std::vector<std::vector<Edge>> g;\n    Dijkstra(int n) : g(n) {}\n    void add_edge(int u, int v, T cost) {\n        g[u].push_back({v, cost});\n        if (!directed) g[v].push_back({u, cost});\n    }\n    std::vector<T> run(int s) {\n        std::vector<T> dist(g.size(), std::numeric_limits<T>::max() / 2);\n        // {d, v}\n        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> q;\n        q.push({0, s});\n        while (!q.empty()) {\n            std::pair<T, int> p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] <= p.first) continue;\n            dist[v] = p.first;\n            for (const Edge& e : g[v]) {\n                if (dist[e.to] <= p.first + e.cost) continue;  // 定数倍枝刈り\n                q.emplace(p.first + e.cost, e.to);\n            }\n        }\n        return dist;\n    }\n};\n",
        "description": "Dijkstra"
    },
    "TwoSat.hpp": {
        "prefix": "TwoSat",
        "body": "#include \"StronglyConnectedComponents.hpp\"\n\nstruct TwoSat {\n    int n;\n    StronglyConnectedComponents scc;  // [0, n): x, [n, 2n): not x\n    TwoSat(int n_) : n(n_), scc(2 * n_) {}\n    // xの否定を表すindex\n    int rev(int x) { return x < n ? x + n : x - n; }\n    // (x \\vee y)の条件を追加\n    void add_condition(int x, bool not_x, int y, bool not_y) {\n        if (not_x) x = rev(x);\n        if (not_y) y = rev(y);\n        scc.add_edge(rev(x), y);\n        scc.add_edge(rev(y), x);\n    }\n    bool run() {\n        scc.build();\n        for (int x = 0; x < n; x++) {\n            if (scc.belong_to[x] == scc.belong_to[rev(x)]) return false;\n        }\n        return true;\n    }\n    bool is_true(int x) {\n        assert(0 <= x && x < n);\n        return scc.belong_to[x] > scc.belong_to[rev(x)];\n    }\n};\n",
        "description": "TwoSat"
    },
    "AbstractDijkstra.hpp": {
        "prefix": "AbstractDijkstra",
        "body": "/// @docs src/Graph/AbstractDijkstra.md\ntemplate <class Dist, class Key, class Delta>  // Delta: Key from, (Key to, Dist d -> void) update -> void\nstd::map<Key, Dist> dijkstra(Key s, Delta delta) {\n    std::map<Key, Dist> dist;\n    using P = std::pair<Dist, Key>;\n    auto cmp_first = [](const P& a, const P& b) { return a.first > b.first; };\n    std::priority_queue<P, std::vector<P>, decltype(cmp_first)> q{cmp_first};\n    q.push({dist[s] = Dist(), s});\n    while (!q.empty()) {\n        std::pair<Dist, Key> p = q.top();\n        q.pop();\n        if (dist[p.second] < p.first) continue;\n        delta(p.second, [&](Key to, Dist d) -> void {\n            if (dist.count(to) && dist[to] <= p.first + d) return;\n            q.push({dist[to] = p.first + d, to});\n        });\n    }\n    return dist;\n}\n",
        "description": "AbstractDijkstra"
    },
    "LongestCommonPrefix.hpp": {
        "prefix": "LongestCommonPrefix",
        "body": "template <class T = int> class SegTree {\n    using VT = vector<T>;\n    int orig_n;\n    // k番目のノードの[l, r)について[a, b)を求める\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) {\n            return UNIT;\n        }\n        if (a <= l && r <= b) {\n            return dat[k];\n        }\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\npublic:\n    int N;\n    VT dat;\n    function<T(T, T)> f;\n    int UNIT;\n    SegTree(int n, function<T(T, T)> f_, const T unit) {\n        orig_n = n;\n        f = f_;\n        UNIT = unit;\n        for (N = 1; N < n; N *= 2)\n            ;\n        dat = VT(2 * N - 1, UNIT);\n    }\n    SegTree(\n        VT a = {}, function<T(T, T)> f_ = [](int a, int b) { return min(a, b); }, T unit = 1e15) {\n        orig_n = a.size();\n        f = f_;\n        UNIT = unit;\n        for (N = 1; N < a.size(); N *= 2)\n            ;\n        dat = VT(2 * N - 1);\n        REP(i, a.size()) { dat[N - 1 + i] = a[i]; }\n        for (int k = N - 2; k >= 0; k--) {\n            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // k番目をaに\n    void update(int k, int a) {\n        k += N - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // [a, b)でのクエリ\n    T query(int a, int b) {\n        assert(0 <= a && a < b && b <= orig_n);\n        return query(a, b, 0, 0, N);\n    }\n};\n\n// SA-ISによるSuffix Arrayの実装。構築O(N)\nclass SuffixArray {\n    vector<int> sa_is(const vector<int>& str, const int k) {\n        const int n = str.size();\n        vector<bool> is_S(n);\n        is_S[n - 1] = true;\n        vector<bool> is_LMS(n);\n        vector<int> LMSs;\n        for (int i = n - 2; i >= 0; i--) {\n            is_S[i] = str[i] < str[i + 1] || (str[i] == str[i + 1] && is_S[i + 1]);\n        }\n        REP(i, n) {\n            if (is_S[i] & (i == 0 || !is_S[i - 1])) {\n                is_LMS[i] = true;\n                LMSs.push_back(i);\n            }\n        }\n        vector<int> pseudo_sa = induced_sort(str, LMSs, is_S, k);\n        vector<int> orderedLMSs(LMSs.size());\n        int index = 0;\n        for (int x : pseudo_sa) {\n            if (is_LMS[x]) {\n                orderedLMSs[index++] = x;\n            }\n        }\n        pseudo_sa[orderedLMSs[0]] = 0;\n        int rank = 0;\n        if (orderedLMSs.size() > 1) {\n            pseudo_sa[orderedLMSs[1]] = ++rank;\n        }\n        REPI(i, 1, orderedLMSs.size() - 1) {\n            bool is_diff = false;\n            REP(j, n) {\n                int p = orderedLMSs[i] + j;\n                int q = orderedLMSs[i + 1] + j;\n                if (str[p] != str[q] || is_LMS[p] != is_LMS[q]) {\n                    is_diff = true;\n                    break;\n                }\n                if (j > 0 && is_LMS[p]) {\n                    break;\n                }\n            }\n            pseudo_sa[orderedLMSs[i + 1]] = is_diff ? ++rank : rank;\n        }\n        vector<int> new_str(LMSs.size());\n        index = 0;\n        REP(i, n) {\n            if (is_LMS[i]) {\n                new_str[index++] = pseudo_sa[i];\n            }\n        }\n        vector<int> LMS_sa;\n        if (rank + 1 == LMSs.size()) {\n            LMS_sa = orderedLMSs;\n        } else {\n            LMS_sa = sa_is(new_str, rank + 1);\n            for (int& x : LMS_sa) {\n                x = LMSs[x];\n            }\n        }\n        return induced_sort(str, LMS_sa, is_S, k);\n    }\n\n    vector<int> induced_sort(const vector<int>& str, const vector<int>& LMSs, const vector<bool>& is_S, const int k) {\n        int n = str.size();\n        vector<int> buckets(n);\n        vector<int> chars(k + 1);\n        for (int c : str) {\n            chars[c + 1]++;\n        }\n        REP(i, k) { chars[i + 1] += chars[i]; }\n        vector<int> count(k);\n        for (int i = LMSs.size() - 1; i >= 0; i--) {\n            int c = str[LMSs[i]];\n            buckets[chars[c + 1] - 1 - count[c]++] = LMSs[i];\n        }\n        count = vector<int>(k);\n        REP(i, n) {\n            if (buckets[i] == 0 || is_S[buckets[i] - 1]) {\n                continue;\n            }\n            int c = str[buckets[i] - 1];\n            buckets[chars[c] + count[c]++] = buckets[i] - 1;\n        }\n        count = vector<int>(k);\n        for (int i = n - 1; i >= 0; i--) {\n            if (buckets[i] == 0 || !is_S[buckets[i] - 1]) {\n                continue;\n            }\n            int c = str[buckets[i] - 1];\n            buckets[chars[c + 1] - 1 - count[c]++] = buckets[i] - 1;\n        }\n        return buckets;\n    }\n\npublic:\n    string S;\n    int N;\n    vector<int> sa;  // sa[i]: suffixが辞書順i番目となる開始位置のindex\n    SuffixArray(string str_in) : S(str_in), N(str_in.size()) {\n        str_in += \"$\";\n        vector<int> str(N + 1);\n        REP(i, N + 1) { str[i] = str_in[i] - '$'; }\n        sa = sa_is(str, 128);\n        sa.erase(sa.begin());\n    }\n    int operator[](int index) { return sa[index]; }\n\n    // sizeがTと等しく初めてT以上になるようなSの部分文字列(sa)\n    vector<int>::iterator lower_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sa[mid], T.size(), T) < 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sa.begin() + r;\n    }\n\n    // sizeがTと等しく初めてTより大きくなるようなSの部分文字列(sa)\n    vector<int>::iterator upper_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sa[mid], T.size(), T) <= 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sa.begin() + r;\n    }\n\n    // S2が部分文字列として何回出現するか\n    int count(string S2) { return upper_bound(S2) - lower_bound(S2); }\n};\n\nclass LongestCommonPrefix {\n    SegTree<> rmq;\n    vector<int> lcp;  // lcp[i]: S[sa[i]..]とS[sa[i + 1]..]が先頭何文字一致しているか、lcp[N - 1] = 0\n    vector<int> lcp_begin;  // lcp_begin[i]: S[0..]とS[i]が先頭何文字一致しているか\npublic:\n    const string S;\n    int N;\n    vector<int> sa;\n    vector<int> rank;  // rank[i]: iから始まるsuffixの辞書順での順位\n    LongestCommonPrefix();\n    LongestCommonPrefix(const string& str) : S(str), N(str.size()), rank(str.size()), lcp(str.size()) {\n        sa = SuffixArray(str).sa;\n        // rankの設定\n        REP(i, N) { rank[sa[i]] = i; }\n        // S[i]を順番に見ていきS[i - 1] -　1文字以上が共通することを利用してしゃくとり\n        lcp = vector<int>(N);\n        int h = 0;\n        REP(i, N) {\n            if (h > 0) h--;\n            if (rank[i] == N - 1) continue;\n            int j = sa[rank[i] + 1];  // 比べる対象(辞書順が一つ大きいもの)\n            for (; i + h < N && j + h < N; h++) {\n                if (S[i + h] != S[j + h]) break;\n            }\n            lcp[rank[i]] = h;\n        }\n        // 必要に応じてコメントアウト\n        set_query1();\n        set_query2();\n    }\n    int operator[](int index) { return lcp[index]; }\n\n    // S[i..], S[j..]が先頭何文字一致しているか\n    int query(int i, int j) {\n        assert(0 <= i && 0 <= j && i < N && j < N);\n        if (i == j) return N - i;\n        int l = min(rank[i], rank[j]);\n        int r = max(rank[i], rank[j]);\n        return rmq.query(l, r);\n    }\n    void set_query2() {\n        // S[i..], S[j..]のlcpが求められるようにRMQ上にのせる\n        rmq = SegTree<int>(\n            lcp, [](int a, int b) { return min(a, b); }, 1e15);\n    }\n\n    // S[i..]がS[0..]と先頭文字一致しているか\n    int query(int i) { return lcp_begin[i]; }\n    void set_query1() {\n        lcp_begin = vector<int>(N);\n        lcp_begin[0] = N;\n        for (int i = rank[0] - 1; i >= 0; i--) {\n            lcp_begin[sa[i]] = min(lcp_begin[sa[i + 1]], lcp[i]);\n        }\n        for (int i = rank[0] + 1; i < N; i++) {\n            lcp_begin[sa[i]] = min(lcp_begin[sa[i - 1]], lcp[i - 1]);\n        }\n    }\n};\n",
        "description": "LongestCommonPrefix"
    },
    "FenwickTree.hpp": {
        "prefix": "FenwickTree",
        "body": "// 0-indexed\ntemplate <class T> struct FenwickTree {\n    const T e;\n    FenwickTree(T e_ = 0) : e(e_) {}\n    int n;\n    vector<T> t;\n    void set_by_identity(int n_) {\n        n = n_;\n        t.clear(), t.resize(n, e);\n    }\n    void set_by_vector(const vector<T>& a) {\n        n = a.size();\n        t.clear(), t = a;\n        for (int i = 0; i < n - 1; i++) {\n            if ((i | (i + 1)) < n) t[i | (i + 1)] = op(t[i | (i + 1)], t[i]);\n        }\n    }\n    // a番目にxを加算\n    void add(int a, T x) {\n        for (int i = a; i < n; i |= i + 1) {\n            t[i] += x;\n        }\n    }\n\n    // [0, a)、a == 0のときは0を返す\n    T query(int a) const {\n        T ret = 0;\n        for (int i = a - 1; i >= 0; i = (i & (i + 1)) - 1) {\n            ret += t[i];\n        }\n        return ret;\n    }\n    // [a, b)\n    T query(int a, int b) const {\n        assert(a <= b);\n        return query(b) - query(a);\n    }\n    T operator[](int a) const { return query(a, a + 1); }\n    // k番目をxに\n    void update(int a, T x) { add(a, x - operator[](a)); }\n\n    // 注: 中身が全て正のときしか動かない\n    // query[0, i] >= xとなるような最小のi\n    int lower_bound(T x) const {\n        int i = -1;\n        for (int w = 1 << __lg(n); w > 0; w >>= 1) {\n            if (i + w < n && t[i + w] < x) {\n                x -= t[i + w];\n                i += w;\n            }\n        }\n        return i + 1;\n    }\n    // query[begin, i + 1) >= xとなるような最小のi\n    int lower_bound(int begin, T x) const {\n        int lb = lower_bound(x + query(begin));\n        return max(begin, lb);\n    }\n    // query(i + 1) > xとなるような最小のi\n    int upper_bound(T x) const {\n        int i = -1;\n        for (int w = 1 << __lg(n); w > 0; w /= 2) {\n            if (i + w < n && t[i + w] <= x) {\n                x -= t[i + w];\n                i += w;\n            }\n        }\n        return i + 1;\n    }\n    // query[begin, i + 1) > xとなるような最小のi\n    int upper_bound(int begin, T x) const {\n        int ub = upper_bound(x + query(begin));\n        return max(begin, ub);\n    }\n    friend string to_string(const FenwickTree<T>& ft) {\n        vector<T> ret(ft.n);\n        for (int i = 0; i < ft.n; i++) ret[i] = ft.operator[](i);\n        return to_string(ret);\n    }\n};\n",
        "description": "FenwickTree"
    },
    "ErdosGallai.hpp": {
        "prefix": "ErdosGallai",
        "body": "// Erdos-Gallai theorem: (O(n))\n// https://en.wikipedia.org/wiki/Erdős–Gallai_theorem\nbool is_graphic(const VI& d) {\n    int n = d.size();\n    if (accumulate(ALL(d), 0LL) % 2) return false;\n    VI acc(n + 1);\n    REP(i, n) { acc[i + 1] = acc[i] + d[i]; }\n    int l = n - 1;  // d[l] >= i + 1を満たす最大のl\n    REP(i, n) {\n        int lhs = acc[i + 1];\n        while (l >= i + 1 && d[l] < i + 1) l--;\n        // [i + 1, l]: i + 1, [l + 1, n - 1]: acc\n        int rhs = i * (i + 1) + (i + 1) * (l - i) + (acc[n] - acc[l + 1]);\n        if (lhs > rhs) return false;\n    }\n    return true;\n}\n\nsigned main() {\n    // verify: https://atcoder.jp/contests/yahoo-procon2018-qual/submissions/3925879\n    int n;\n    cin >> n;\n    VI d(n);\n    REP(i, n) cin >> d[i];\n\n    sort(RALL(d));\n    if (is_graphic(d)) {\n        cout << \"YES\" << endl;\n    } else {\n        d.back() += 1;\n        sort(RALL(d));\n        if (is_graphic(d)) {\n            cout << \"NO\" << endl;\n        } else {\n            cout << \"ABSOLUTELY NO\" << endl;\n        }\n    }\n}\n",
        "description": "ErdosGallai"
    },
    "EulerTotient.hpp": {
        "prefix": "EulerTotient",
        "body": "int euler_totient(int n) {\n    vector<int> ps;\n    {\n        int tmp = n;\n        for (int x = 2; x * x <= tmp; x++) {\n            if (tmp % x) continue;\n            ps.push_back(x);\n            while (tmp % x == 0) tmp /= x;\n        }\n        if (tmp != 1) ps.push_back(tmp);\n    }\n    int m = ps.size();\n    int ans = 0;\n    for (int bit = 0; bit < 1LL << m; bit++) {\n        int d = 1;\n        for (int i = 0; i < m; i++) {\n            if (bit >> i & 1) d *= ps[i];\n        }\n        int sign = __builtin_popcount(bit) % 2 ? -1 : 1;\n        ans += sign * (n / d);\n    }\n    return ans;\n}\n",
        "description": "EulerTotient"
    },
    "LongestCommonSubsequence.hpp": {
        "prefix": "LongestCommonSubsequence",
        "body": "// Longest Common Subsequence: O(nm)\nvector<vector<int>> LCS(const vector<int>& s, const vector<int>& t) {\n    int n = s.size(), m = t.size();\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i + 1][j + 1] = s[i] == t[j] ? dp[i][j] + 1 : max(dp[i][j + 1], dp[i + 1][j]);\n        }\n    }\n    return dp;\n}\n// メモリ節約\nvector<vector<int>> LCS2(const vector<int>& s, const vector<int>& t) {\n    int n = s.size(), m = t.size();\n    vector<vector<int>> dp(2, vector<int>(m + 1));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[1][j + 1] = s[i] == t[j] ? dp[0][j] + 1 : max(dp[0][j + 1], dp[1][j]);\n        }\n        swap(dp[0], dp[1]);\n    }\n    return dp;\n}\n",
        "description": "LongestCommonSubsequence"
    },
    "TreeDiameter.hpp": {
        "prefix": "TreeDiameter",
        "body": "// 木の直径がdiameterに格納される\nsigned main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    REP(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int diameter = 0;\n    function<int(int, int)> dfs = [&](int v, int p) {\n        int ma = 0;\n        for (int s : g[v])\n            if (s != p) {\n                int tmp = dfs(s, v) + 1;\n                diameter = max(diameter, ma + tmp);\n                ma = max(ma, tmp);\n            }\n        return ma;\n    };\n    dfs(0, -1);\n}\n",
        "description": "TreeDiameter"
    },
    "ReversedBinaryIndexedTree.hpp": {
        "prefix": "ReversedBinaryIndexedTree",
        "body": "// 0-indexed\nclass BinaryIndexedTree {\n    int max_pow;  // N以下の最大の2べき\npublic:\n    vector<int> bit;\n    int N;\n    BinaryIndexedTree(int n, int x = 0) : N(n), bit(n, x) {\n        for (max_pow = 1; max_pow <= N / 2; max_pow *= 2)\n            ;\n    }\n    BinaryIndexedTree(const vector<int>& a) : N(a.size()), bit(a) {\n        for (max_pow = 1; max_pow <= N / 2; max_pow *= 2)\n            ;\n        REP(i, N - 1) if ((i | (i + 1)) < N) { bit[i | (i + 1)] += bit[i]; }\n    }\n    // k番目にxを加算\n    void add(int k, int x) {\n        for (int i = k; i < N; i |= i + 1) {\n            bit[i] += x;\n        }\n    }\n\n    // [0, k)、k == 0のときは0を返す\n    int sum(int k) {\n        int ret = 0;\n        for (int i = k - 1; i >= 0; i = (i & (i + 1)) - 1) {\n            ret += bit[i];\n        }\n        return ret;\n    }\n    int sum() { return sum(N); }\n\n    // [a, b)\n    int query(int a, int b) {\n        assert(a <= b);\n        return sum(b) - sum(a);\n    }\n    int operator[](int k) { return query(k, k + 1); }\n\n    // k番目をxに\n    void update(int k, int x) { add(k, x - operator[](k)); }\n\n    // 注: 中身が全て正のときしか動かない\n    // sum(i + 1) >= xとなるような最小のi\n    int lower_bound(int x) {\n        int i = -1;\n        for (int w = max_pow; w > 0; w /= 2) {\n            if (i + w < N && bit[i + w] < x) {\n                x -= bit[i + w];\n                i += w;\n            }\n        }\n        return i + 1;\n    }\n    // query[begin, i + 1) >= xとなるような最小のi\n    int lower_bound(int begin, int x) {\n        int lb = lower_bound(x + sum(begin));\n        return max(begin, lb);\n    }\n    // sum(i + 1) > xとなるような最小のi\n    int upper_bound(int x) {\n        int i = -1;\n        for (int w = max_pow; w > 0; w /= 2) {\n            if (i + w < N && bit[i + w] <= x) {\n                x -= bit[i + w];\n                i += w;\n            }\n        }\n        return i + 1;\n    }\n    // query[begin, i + 1) > xとなるような最小のi\n    int upper_bound(int begin, int x) {\n        int ub = upper_bound(x + sum(begin));\n        return max(begin, ub);\n    }\n};\n\n// 大きい方からlower_boundなどをしたいときのwrapper\n// 政府逆転させて(-N, 0]にして、平行移動して[0, N)にしている\nclass ReversedBinaryIndexedTree : public BinaryIndexedTree {\npublic:\n    using BinaryIndexedTree::BinaryIndexedTree;\n    int rev(int k) { return N - 1 - k; }\n    void add(int k, int x) { BinaryIndexedTree::add(rev(k), x); }\n    // (k, N-1]\n    int sum(int k) { return BinaryIndexedTree::sum(rev(k)); }\n    // query(i - 1, N-1] >= xとなるような最大nのi\n    int lower_bound(int x) { return rev(BinaryIndexedTree::lower_bound(x)); }\n    // query(i - 1, N-1] > xとなるような最大nのi\n    int upper_bound(int x) { return rev(BinaryIndexedTree::upper_bound(x)); }\n};\n",
        "description": "ReversedBinaryIndexedTree"
    },
    "GaussJordan.hpp": {
        "prefix": "GaussJordan",
        "body": "// A[n-1]にはAx = bのbの値\ntemplate <class T> void gauss_jordan(vector<vector<T>>& A) {\n    int n = A.size(), m = A[0].size();\n    vector<bool> used(n);\n    for (int col = 0; col < m - 1; col++) {\n        int pivot = -1;\n        for (int row = 0; row < n; row++) {\n            if (!used[row] && A[row][col] != 0) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        used[pivot] = true;\n        for (int row = 0; row < n; row++) {\n            if (row == pivot) continue;\n            T d = A[row][col] / A[pivot][col];  // 倍率\n            for (int col2 = 0; col2 < m; col2++) {\n                A[row][col2] -= A[pivot][col2] * d;\n            }\n        }\n    }\n}\n",
        "description": "GaussJordan"
    },
    "AllDirectionTreeDP.hpp": {
        "prefix": "AllDirectionTreeDP",
        "body": "// 全方位木DP\n// ds[v]: vを根としたときのそれぞれの葉までの距離\nsigned main() {\n    struct Edge {\n        int to, c;\n    };\n    int n;\n    cin >> n;\n    vector<vector<Edge>> G(n);\n    REP(i, n - 1) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        G[s].push_back({t, w});\n        G[t].push_back({s, w});\n    }\n    VVII ds(n);\n    function<int(int, int)> dfs1 = [&](int v, int p) {\n        int ma = 0;\n        for (Edge e : G[v])\n            if (e.to != p) {\n                int tmp = dfs1(e.to, v) + e.c;\n                ds[v].push_back({tmp, e.to});\n                ma = max(ma, tmp);\n            }\n        return ma;\n    };\n    dfs1(0, -1);\n\n    sort(RALL(ds[0]));\n    function<void(int, int)> dfs2 = [&](int v, int p) {\n        for (Edge e : G[v])\n            if (e.to != p) {\n                int tmp = (ds[v][0].se != e.to ? ds[v][0].fi : (ds[v].size() == 1 ? 0 : ds[v][1].fi)) + e.c;\n                ds[e.to].push_back({tmp, v});\n                sort(RALL(ds[e.to]));\n                dfs2(e.to, v);\n            }\n    };\n    dfs2(0, -1);\n\n    int ans = 0;\n    REP(i, n) {\n        if (ds[i].size() == 0) continue;\n        ans = max(ans, ds[i][0].fi);\n    }\n    cout << ans << endl;\n}\n",
        "description": "AllDirectionTreeDP"
    },
    "DynamicModInt.hpp": {
        "prefix": "DynamicModInt",
        "body": "template <class T> T pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\n// ModInt::set_mod(m)してから使う\nstruct ModInt {\n    static int MD;\n    static map<pair<int, int>, int> tbl_pow;\n    static void set_mod(int mod) {\n        MD = mod;\n        tbl_pow.clear();\n    }\n    int x;\n    ModInt() : x(0) {}\n    ModInt(int x_) {\n        if ((x = x_ % MD + MD) >= MD) x -= MD;\n    }\n\n    ModInt& operator+=(ModInt that) {\n        if ((x += that.x) >= MD) x -= MD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        x = (unsigned long long)x * that.x % MD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        if ((x -= that.x) < 0) x += MD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt that) {\n        x = (unsigned long long)x * that.inv().x % MD;\n        return *this;\n    }\n\n    ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt inv() const { return pow(*this, MD - 2); }\n    friend ostream& operator<<(ostream& s, ModInt a) {\n        s << a.x;\n        return s;\n    }\n    friend istream& operator>>(istream& s, ModInt& a) {\n        s >> a.x;\n        return s;\n    }\n\n    // 計算結果をmapに保存するべき乗\n    ModInt save_pow(int n) const {\n        if (tbl_pow.count({x, n})) return tbl_pow[{x, n}];\n        if (n == 0) return 1;\n        if (n % 2) return tbl_pow[{x, n}] = (*this * save_pow(n - 1)).x;\n        return tbl_pow[{x, n}] = (save_pow(n / 2) * save_pow(n / 2)).x;\n    }\n    // 1 + r + r^2 + ... + r^(n-1)\n    static ModInt geometric_progression(ModInt r, int n) {\n        if (n == 0) return 0;\n        if (n % 2) return geometric_progression(r, n - 1) + r.save_pow(n - 1);\n        return geometric_progression(r, n / 2) * (r.save_pow(n / 2) + 1);\n    }\n    // a + r * (a - d) + r^2 * (a - 2d) + ... + r^(n-1) * (a - (n - 1)d)\n    static ModInt linear_sum(ModInt r, ModInt a, ModInt d, int n) {\n        if (n == 0) return 0;\n        if (n % 2) return linear_sum(r, a, d, n - 1) + r.save_pow(n - 1) * (a - d * (n - 1));\n        return linear_sum(r, a, d, n / 2) * (r.save_pow(n / 2) + 1) -\n               d * (n / 2) * r.save_pow(n / 2) * geometric_progression(r, n / 2);\n    }\n};\nint ModInt::MD = 1000000007;\nusing mint = ModInt;\nmap<pair<int, int>, int> mint::tbl_pow;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n    fact = vector<mint>(n + 1, 1);\n    fact_inv = vector<mint>(n + 1);\n    for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[n] = mint(1) / fact[n];\n    for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n    // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n",
        "description": "DynamicModInt"
    },
    "MultisetHash.hpp": {
        "prefix": "MultisetHash",
        "body": "using ull = unsigned long long;\nrandom_device rnd;\nmt19937 mt(rnd());\nmt19937_64 mt64(rnd());\nint mod_pow(int x, int n, int mod) {\n    if (n <= 0) return 1;\n    int tmp = mod_pow(x, n / 2, mod);\n    return tmp * tmp % mod * (n % 2 ? x : 1) % mod;\n}\n// Miller-Rabin\nbool is_prime(int n, int times = 50) {\n    if (n == 2) return true;\n    if (n % 2 == 0 || n < 2) return false;\n    int d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    while (times--) {\n        int a = rnd() % (n - 2) + 1;\n        int t = d;\n        int y = mod_pow(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t *= 2;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint gen_prime() {\n    int cnt = 0;\n    while (1) {\n        int n = mt();\n        n != 1;\n        if (is_prime(n)) return n;\n    }\n}\nclass MultisetHash {\npublic:\n    vector<ull> hash, pows;\n    ull mod;\n    int to_int(char c) { return c - 'a'; }\n    MultisetHash() {}\n    MultisetHash(const string& S, int k = 26, ull base = gen_prime(), ull m = gen_prime())\n        : hash(S.size() + 1), pows(k), mod(m) {\n        pows[0] = 1;\n        for (int i = 0; i < k - 1; i++) {\n            pows[i + 1] = pows[i] * base % mod;\n        }\n        for (int i = 0; i < S.size(); i++) {\n            hash[i + 1] = hash[i] + pows[to_int(S[i])];\n        }\n    }\n    // [l, r)\n    ull get(int l, int r) {\n        int ret = hash[r] + mod - hash[l];\n        if (ret >= mod) ret -= mod;\n        return ret;\n    }\n};\n",
        "description": "MultisetHash"
    },
    "FFT.hpp": {
        "prefix": "FFT",
        "body": "struct FFT {\n    using comp = complex<double>;\n    static void fft(vector<comp>& a, bool inv = false) {\n        int N = a.size();\n        if (N == 1) {\n            return;\n        }\n        vector<comp> even(N / 2), odd(N / 2);\n        for (int i = 0; i < N / 2; i++) {\n            even[i] = a[2 * i];\n            odd[i] = a[2 * i + 1];\n        }\n        fft(even, inv);\n        fft(odd, inv);\n        comp omega = polar(1.0, (-2 * inv + 1) * 2 * M_PI / N);\n        comp acc_omega = comp(1);\n        for (int i = 0; i < N / 2; i++) {\n            a[i] = even[i] + acc_omega * odd[i];\n            a[i + N / 2] = even[i] - acc_omega * odd[i];\n            acc_omega *= omega;\n        }\n    }\n    static void conv(vector<int>& a, vector<int>& b) {\n        int N = 1;\n        while (N < 2 * (max(a.size(), b.size() + 1))) {\n            N *= 2;\n        }\n        vector<comp> ac(N, comp(0)), bc(N, comp(0));\n        for (int i = 0; i < a.size(); i++) ac[i] = comp(a[i]);\n        for (int i = 0; i < b.size(); i++) bc[i] = comp(b[i]);\n        multiply(ac, bc);\n        a.resize(N);\n        for (int i = 0; i < N; i++) {\n            a[i] = (int)(ac[i].real() + 0.5);\n        }\n    }\n\nprivate:\n    static void multiply(vector<comp>& a, vector<comp>& b) {\n        int n = a.size();\n        fft(a);\n        fft(b);\n        for (int i = 0; i < n; i++) {\n            a[i] *= b[i] / comp(n);\n        }\n        fft(a, true);\n    }\n};\n",
        "description": "FFT"
    },
    "SuffixArrayDoubling.hpp": {
        "prefix": "SuffixArrayDoubling",
        "body": "template <class T = int> class SegTree {\n    using VT = vector<T>;\n    int orig_n;\n    // k番目のノードの[l, r)について[a, b)を求める\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) {\n            return UNIT;\n        }\n        if (a <= l && r <= b) {\n            return dat[k];\n        }\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\npublic:\n    int N;\n    VT dat;\n    function<T(T, T)> f;\n    int UNIT;\n    SegTree(int n, function<T(T, T)> f_, const T unit) {\n        orig_n = n;\n        f = f_;\n        UNIT = unit;\n        for (N = 1; N < n; N *= 2)\n            ;\n        dat = VT(2 * N - 1, UNIT);\n    }\n    SegTree(\n        VT a = {}, function<T(T, T)> f_ = [](int a, int b) { return min(a, b); }, T unit = 1e15) {\n        orig_n = a.size();\n        f = f_;\n        UNIT = unit;\n        for (N = 1; N < a.size(); N *= 2)\n            ;\n        dat = VT(2 * N - 1);\n        REP(i, a.size()) { dat[N - 1 + i] = a[i]; }\n        for (int k = N - 2; k >= 0; k--) {\n            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // k番目をaに\n    void update(int k, int a) {\n        k += N - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // [a, b)でのクエリ\n    T query(int a, int b) {\n        assert(0 <= a && a < b && b <= orig_n);\n        return query(a, b, 0, 0, N);\n    }\n};\n\nclass SuffixArray {\n    SegTree<> rmq;\n    void set_lcp() {\n        // S[i]を順番に見ていきS[i - 1] -　1文字以上が共通することを利用してしゃくとり\n        lcp_next_rank = vector<int>(N);\n        int h = 0;\n        REP(i, N) {\n            if (h > 0) h--;\n            if (rank[i] == N - 1) continue;\n            int j = sorted[rank[i] + 1];  // 比べる対象(辞書順が一つ大きいもの)\n            for (; i + h < N && j + h < N; h++) {\n                if (S[i + h] != S[j + h]) break;\n            }\n            lcp_next_rank[rank[i]] = h;\n        }\n        // S[i..], S[j..]のlcpが求められるようにRMQ上にのせる\n        rmq = SegTree<int>(\n            lcp_next_rank, [](int a, int b) { return min(a, b); }, 1e15);\n    }\n\npublic:\n    int N;\n    string S;\n    vector<int> rank;    // rank[i]: iから始まるsuffixの辞書順での順位\n    vector<int> sorted;  // sorted[i]: suffixが辞書順i番目となる開始位置のindex\n    vector<int> lcp_next_rank;  // lcp[i]: S[sorted[i]..]とS[sorted[i + 1]..]が先頭何文字一致しているか、lcp[N - 1] = 0\n    SuffixArray(string s) {\n        S = s;\n        N = S.size();\n        sorted = vector<int>(N);\n        rank = vector<int>(N);\n        REP(i, N) {\n            sorted[i] = i;\n            rank[i] = S[i];\n        }\n\n        int k;\n        function<bool(int, int)> compare_sa = [this, &k](int i, int j) {\n            if (rank[i] != rank[j]) {\n                return rank[i] < rank[j];\n            }\n            int ri = i + k < N ? rank[i + k] : -1;\n            int rj = j + k < N ? rank[j + k] : -1;\n            return ri < rj;\n        };\n\n        for (k = 1; k < N; k *= 2) {\n            sort(sorted.begin(), sorted.end(), compare_sa);\n            vector<int> tmp(N, 0);\n            REPI(i, 1, N) { tmp[sorted[i]] = tmp[sorted[i - 1]] + compare_sa(sorted[i - 1], sorted[i]); }\n            rank = tmp;\n        }\n        set_lcp();\n    }\n\n    // sizeがTと等しく初めてT以上になるようなSの部分文字列(sortedのイテレータを返す)\n    vector<int>::iterator lower_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sorted[mid], T.size(), T) < 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sorted.begin() + r;\n    }\n\n    // sizeがTと等しく初めてTより大きくなるようなSの部分文字列(sortedのイテレータを返す)\n    vector<int>::iterator upper_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sorted[mid], T.size(), T) <= 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sorted.begin() + r;\n    }\n\n    // S2が部分文字列として何回出現するか\n    int count(string S2) { return upper_bound(S2) - lower_bound(S2); }\n\n    // S[i..], S[j..]が先頭何文字一致しているか\n    int lcp(int i, int j) {\n        assert(0 <= i && 0 <= j && i < N && j < N);\n        if (i == j) return N - i;\n        int l = min(rank[i], rank[j]);\n        int r = max(rank[i], rank[j]);\n        return rmq.query(l, r);\n    }\n};\n",
        "description": "SuffixArrayDoubling"
    },
    "Kruskal.hpp": {
        "prefix": "Kruskal",
        "body": "class UnionFind {\npublic:\n    VI par, rank;\n    UnionFind(int n) {\n        par = VI(n);\n        iota(par.begin(), par.end(), 0);\n        rank = VI(n, 0);\n    }\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = root(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return;\n        }\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n};\n\nstruct edge {\n    int u, v, cost;\n};\nbool comp(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint kruskal(int V, vector<edge>& es) {\n    sort(es.begin(), es.end(), comp);\n    UnionFind uf(V);\n    int ans = 0;\n    for (edge e : es) {\n        if (uf.same(e.u, e.v)) {\n            continue;\n        }\n        uf.unite(e.u, e.v);\n        ans += e.cost;\n    }\n    return ans;\n}\nsigned main() {\n    int V, E;\n    cin >> V >> E;\n    vector<edge> es(E);\n    REP(i, E) { cin >> es[i].u >> es[i].v >> es[i].cost; }\n    cout << kruskal(V, es) << endl;\n}\n",
        "description": "Kruskal"
    },
    "UnionFindRange.hpp": {
        "prefix": "UnionFindRange",
        "body": "// 1次元上の要素のマージをしていくときに、各連結成分の[left, right)を更新\nstruct UnionFind {\n    int cnt;                      // 集合の数\n    vector<int> number;           // 0以上のとき親のindex, 負のときは集合サイズ\n    vector<pair<int, int>> data;  // [left, right)\n    UnionFind(int n) : cnt(n), number(n, -1), data(n) {\n        for (int i = 0; i < n; i++) data[i] = {i, i + 1};\n    }\n    int root(int x) { return number[x] < 0 ? x : number[x] = root(number[x]); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (number[y] < number[x]) swap(x, y);\n        // yをxにマージ\n        number[x] += number[y];\n        number[y] = x;\n        // dataのマージ方法に合わせて変える\n        data[x] = {min(data[x].first, data[y].first), max(data[x].second, data[y].second)};\n        cnt--;\n    }\n    bool is_same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -number[root(x)]; }\n    int& left(int x) { return data[root(x)].first; }\n    int& right(int x) { return data[root(x)].second; }\n    pair<int, int>& ref(int x) { return data[root(x)]; }\n};\n",
        "description": "UnionFindRange"
    },
    "SlideMin.hpp": {
        "prefix": "SlideMin",
        "body": "// 自分を含んだK個前までの中での最小値のindexの配列を返す\n// 最小(最大)値のindexを返すことに注意!\ntemplate <class T = int> vector<int> slide_min(const vector<T>& a, int w, function<bool(T, T)> cmp = less<T>()) {\n    int n = a.size();\n    vector<int> ret(n);\n    deque<int> dq;\n    for (int i = 0; i < n; i++) {\n        while (!dq.empty() && !cmp(a[dq.back()], a[i])) {\n            dq.pop_back();\n        }\n        dq.push_back(i);\n        while (dq.front() <= i - w) {\n            dq.pop_front();\n        }\n        ret[i] = dq.front();\n    }\n    return ret;\n}\n",
        "description": "SlideMin"
    },
    "MillerRabin.hpp": {
        "prefix": "MillerRabin",
        "body": "random_device rnd;\nmt19937 mt(rnd());\nmt19937_64 mt64(rnd());\nint mod_pow(int x, int n, int mod) {\n    if (n <= 0) return 1;\n    int tmp = mod_pow(x, n / 2, mod);\n    return tmp * tmp % mod * (n % 2 ? x : 1) % mod;\n}\nint mod_inv(int x, int mod) { return mod_pow(x, mod - 2, mod); }\n// Miller-Rabin\nbool is_prime(int n, int times = 50) {\n    if (n == 2) return true;\n    if (n % 2 == 0 || n < 2) return false;\n    int d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    while (times--) {\n        int a = rnd() % (n - 2) + 1;\n        int t = d;\n        int y = mod_pow(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t *= 2;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint gen_prime() {\n    int cnt = 0;\n    while (1) {\n        int n = mt();\n        n != 1;\n        if (is_prime(n)) return n;\n    }\n}\n",
        "description": "MillerRabin"
    },
    "GridGraph.hpp": {
        "prefix": "GridGraph",
        "body": "// 二次元Grid Graphの斜め方向の累積和\nclass GridGraph {\n    // queryを計算しやすいようにaccの範囲外の値も便宜的に定義\n    int acc_any(int i, int j) {\n        if (i + j < 0 || H + W - 1 <= i + j) return 0;\n        if (i < 0 || j >= W) return 0;\n        if (j < 0 && i + j < H) return acc[i + j][0];\n        if (i >= H && i + j >= H) return acc[H - 1][i + j - (H - 1)];\n        return acc[i][j];\n    }\n\npublic:\n    VVI t;\n    int H, W;\n    VVI acc;\n    GridGraph(VVI& tbl) : t(tbl), H(tbl.size()), W(tbl[0].size()) { set_acc(); }\n    VI& operator[](int i) { return t[i]; }\n    bool exist(int i, int j) { return 0 <= i && i < H && 0 <= j && j < W && t[i][j]; }\n    // 左下方向への累積和\n    void set_acc() {\n        acc = VVI(H, VI(W));\n        REP(i, H) {\n            REP(j, W) {\n                int before = (i == 0 || j == W - 1) ? 0 : acc[i - 1][j + 1];\n                acc[i][j] = before + t[i][j];\n            }\n        }\n    }\n    // 時計回りに90度回転\n    void rotate() {\n        VVI t2(W, VI(H));\n        REP(i, H) {\n            REP(j, W) { t2[j][H - i - 1] = t[i][j]; }\n        }\n        t = t2;\n        swap(H, W);\n        set_acc();\n    }\n    // [i0, i1)の斜めのsum\n    int query(int i0, int j0, int i1, int j1) {\n        assert(i0 + j0 == i1 + j1);\n        assert(i1 > i0);\n        return acc_any(i1 - 1, j1 + 1) - acc_any(i0 - 1, j0 + 1);\n    }\n};\n\nsigned main() {}\n",
        "description": "GridGraph"
    },
    "Boruvka.hpp": {
        "prefix": "Boruvka",
        "body": "// F(現在の木の個数, vector<頂点->集合のindex>) -> vector<集合のindex->(cost, to)>\n// 使い方: https://codeforces.com/contest/1242/submission/64467604\ntemplate <class T, class F> T boruvka(int n, const F& f) {\n    struct UnionFind {\n        vector<int> number;  // 0以上のとき親のindex, 負のときは集合サイズ\n        UnionFind(int n) : number(n, -1) {}\n        int root(int x) { return number[x] < 0 ? x : number[x] = root(number[x]); }\n        bool unite(int x, int y) {\n            x = root(x), y = root(y);\n            if (x == y) return false;\n            if (number[y] < number[x]) swap(x, y);\n            number[x] += number[y];\n            number[y] = x;\n            return true;\n        }\n    };\n\n    UnionFind uf(n);\n    T res(0);\n    bool update = true;\n    vector<int> belongs(n), rev(n);\n    while (update) {\n        update = false;\n        int ptr = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == uf.root(i)) rev[ptr] = i, belongs[i] = ptr++;\n        }\n        for (int i = 0; i < n; i++) belongs[i] = belongs[uf.root(i)];\n        vector<pair<T, int>> v = f(ptr, belongs);\n        for (int i = 0; i < ptr; i++) {\n            if (v[i].second >= 0 && uf.unite(rev[i], rev[v[i].second])) res += v[i].first, update = true;\n        }\n        if (!update) break;\n    }\n    return res;\n}\n",
        "description": "Boruvka"
    },
    "ChineseRemainderTheorem.hpp": {
        "prefix": "ChineseRemainderTheorem",
        "body": "// ax + by = gcd(a, b) を満たす(x, y)\npair<int, int> ext_gcd(int a, int b) {\n    if (b == 0) return {1, 0};\n    pair<int, int> xy = ext_gcd(b, a % b);  // b(qx + y) + rx = ...\n    swap(xy.fi, xy.se);\n    xy.se -= (a / b) * xy.fi;\n    return xy;\n}\nconst pair<int, int> DUM = {0, -1};\n// r = b[i] (mod m[i])\n// r: 剰余, M: mod\npair<int, int> chinese_rem(const VI& b, const VI& m) {\n    int r = 0, M = 1;\n    for (int i = 0; i < b.size(); i++) {\n        pair<int, int> xy = ext_gcd(M, m[i]);\n        int d = __gcd(M, m[i]);\n        if ((b[i] - r) % d != 0) return DUM;\n        int tmp = ((b[i] - r) / d) * xy.fi % (m[i] / d);\n        r += M * tmp;\n        M *= m[i] / d;\n    }\n    ((r %= M) += M) %= M;\n    return {r, M};\n}\n\nsigned main() {}\n",
        "description": "ChineseRemainderTheorem"
    },
    "UnionFindWithWeight.hpp": {
        "prefix": "UnionFindWithWeight",
        "body": "struct UnionFind {\n    vector<int> par, rank, diff_weight;\n    UnionFind(int n) {\n        par = vector<int>(n);\n        iota(par.begin(), par.end(), 0);\n        rank = vector<int>(n, 0);\n        diff_weight = vector<int>(n, 0);\n    }\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = root(par[x]);\n        }\n    }\n    bool unite(int x, int y, int w) {\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return false;\n        }\n        if (rank[x] < rank[y]) {\n            diff_weight[x] -= w;\n            par[x] = y;\n        } else {\n            diff_weight[y] += w;\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n    int diff(int x, int y) {\n        assert(same(x, y));\n        return weight(y) - weight(x);\n    }\n};\n",
        "description": "UnionFindWithWeight"
    },
    "Divisor.hpp": {
        "prefix": "Divisor",
        "body": "// ret[x]: xの約数のvector\n// 構築: O(nlogn)\nvector<vector<signed>> divisor(signed n) {\n    vector<vector<signed>> ret(n + 1);\n    for (signed i = 1; i < n + 1; i++) {\n        ret[i].reserve(log(n) + 1);\n    }\n    for (signed i = 1; i < n + 1; i++) {\n        for (signed j = i; j < n + 1; j += i) {\n            ret[j].push_back(i);\n        }\n    }\n    return ret;\n}\n",
        "description": "Divisor"
    },
    "ConvexHullTrick.hpp": {
        "prefix": "ConvexHullTrick",
        "body": "template <typename T, const T id = (int)-1e18> class convex_hull_trick {\n    struct line {\n        T a, b;\n        line(T a_ = 0, T b_ = 0) : a(a_), b(b_) {}\n        T get(T x) { return a * x + b; }\n    };\n    struct node {\n        line l;\n        node *lch, *rch;\n        node(line l_) : l(l_), lch(nullptr), rch(nullptr) {}\n        ~node() {\n            if (lch) delete lch;\n            if (rch) delete rch;\n        }\n    };\n\nprivate:\n    const int n;\n    const vector<T> pos;\n    node *root;\n\npublic:\n    convex_hull_trick(const vector<T> &pos_) : n(pos_.size()), pos(pos_), root(nullptr) {}\n    ~convex_hull_trick() {\n        if (root) delete root;\n    }\n    // maxを求めるとき\n    void insert(T a, T b) {\n        line l(a, b);\n        root = modify(root, 0, n - 1, l);\n    }\n    T get(T x) const {\n        int t = lower_bound(pos.begin(), pos.end(), x) - pos.begin();\n        assert(t < n && pos[t] == x);\n        return sub(root, 0, n - 1, t);\n    }\n    // minを求めるとき\n    void rev_insert(T a, T b) { insert(-a, -b); }\n    T rev_get(T x) const { return -get(x); }\n\nprivate:\n    node *modify(node *p, int lb, int ub, line &l) {\n        if (!p) return new node(l);\n        if (p->l.get(pos[lb]) >= l.get(pos[lb]) && p->l.get(pos[ub]) >= l.get(pos[ub])) return p;\n        if (p->l.get(pos[lb]) <= l.get(pos[lb]) && p->l.get(pos[ub]) <= l.get(pos[ub])) {\n            p->l = l;\n            return p;\n        }\n        int c = (lb + ub) / 2;\n        if (p->l.get(pos[c]) < l.get(pos[c])) swap(p->l, l);\n        if (p->l.get(pos[lb]) <= l.get(pos[lb]))\n            p->lch = modify(p->lch, lb, c, l);\n        else\n            p->rch = modify(p->rch, c + 1, ub, l);\n        return p;\n    }\n    T sub(node *p, int lb, int ub, int t) const {\n        if (!p) return id;\n        if (ub - lb == 0) return p->l.get(pos[t]);\n        int c = (lb + ub) / 2;\n        if (t <= c) return max(p->l.get(pos[t]), sub(p->lch, lb, c, t));\n        return max(p->l.get(pos[t]), sub(p->rch, c + 1, ub, t));\n    }\n};\n",
        "description": "ConvexHullTrick"
    },
    "Geometry.hpp": {
        "prefix": "Geometry",
        "body": "const double EPS = 1e-8;\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n// 点、ベクトル\nusing P = complex<double>;\nconst P DUM = {INF + 12345, INF + 67890};\nnamespace std {\nbool operator<(const P& a, const P& b) { return a.X != b.X ? a.X < b.X : a.Y < b.Y; }\n}  // namespace std\ndouble dot(const P& a, const P& b) { return a.X * b.X + a.Y * b.Y; }\ndouble cross(const P& a, const P& b) { return a.X * b.Y - a.Y * b.X; }\ndouble manhattan(const P& a, const P& b) { return abs(a.X - b.X) + abs(a.Y - b.Y); }\n\n// 直線 ax + by + c = 0;\nstruct Line {\n    double a, b, c;\n    Line(double a, double b, double c) : a(a), b(b), c(c) {}\n};\nbool parallel(const Line& l1, const Line& l2) { return EQ(l1.a * l2.b, l1.b * l2.a); }\nP intersection(const Line& l1, const Line& l2) {\n    if (parallel(l1, l2)) return DUM;\n    P vec = {l1.b * l2.c - l2.b * l1.c, l2.a * l1.c - l1.a * l2.c};\n    return vec / (l1.a * l2.b - l1.b * l2.a);\n}\n\n// 線分\nstruct Segment {\n    P p1, p2;\n    Segment(const P& p1, const P& p2) : p1(p1), p2(p2) {}\n    double len() const { return abs(p2 - p1); }\n    bool between(P p) const { return (p1.X - p.X) * (p2.X - p.X) < EPS && (p1.Y - p.Y) * (p2.Y - p.Y) < EPS; }\n    Line to_line() const {\n        P v = p2 - p1;\n        return Line(v.Y, v.X, -(v.Y * p1.X + v.X * p1.Y));\n    }\n};\n// 線分と点の距離\ndouble dist(const Segment& s, const P& p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < EPS) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < EPS) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)) / s.len();\n}\n\n// 直線と線分の交点\nP intersection(const Line& l1, const Segment& s) {\n    Line l2 = s.to_line();\n    P p = intersection(l1, l2);\n    if (!s.between(p)) return DUM;\n    return p;\n}\n\n// 円\nstruct Circle {\n    P p;\n    double r;\n    Circle(const P& p, double r) : p(p), r(r) {}\n};\n",
        "description": "Geometry"
    },
    "ModInt.hpp": {
        "prefix": "ModInt",
        "body": "template <class T> T pow(T x, long long n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\n/// @docs src/Math/ModInt.md\ntemplate <int Mod> struct ModInt {\n    int x;\n    static int& runtime_mod() {\n        static int runtime_mod_;\n        return runtime_mod_;\n    }\n    // テンプレート引数が負のときは実行時ModInt\n    static constexpr int mod() { return Mod < 0 ? runtime_mod() : Mod; }\n    static std::unordered_map<int, int>& to_inv() {\n        static std::unordered_map<int, int> to_inv_;\n        return to_inv_;\n    }\n    static void set_runtime_mod(int mod) {\n        static_assert(Mod < 0, \"template parameter Mod must be negative for runtime ModInt\");\n        runtime_mod() = mod, to_inv().clear();\n    }\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % mod() + mod()) >= mod()) x -= mod();\n    }\n\n    ModInt& operator+=(ModInt rhs) {\n        if ((x += rhs.x) >= mod()) x -= mod();\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.x % mod();\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        if ((x -= rhs.x) < 0) x += mod();\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        ModInt inv = to_inv().count(rhs.x) ? to_inv()[rhs.x] : (to_inv()[rhs.x] = pow(rhs, mod() - 2).x);\n        return *this *= inv;\n    }\n    ModInt operator-() const { return -x < 0 ? mod() - x : -x; }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n\n    friend std::ostream& operator<<(std::ostream& s, ModInt<Mod> a) { return s << a.x; }\n    friend std::istream& operator>>(std::istream& s, ModInt<Mod>& a) {\n        long long tmp;\n        s >> tmp;\n        a = ModInt<Mod>(tmp);\n        return s;\n    }\n    friend std::string to_string(ModInt<Mod> a) { return std::to_string(a.x); }\n};\n\n#ifndef CALL_FROM_TEST\nusing mint = ModInt<1000000007>;\n#endif\n",
        "description": "ModInt"
    },
    "Eratosthenes.hpp": {
        "prefix": "Eratosthenes",
        "body": "/// @docs src/Math/Eratosthenes.md\nstruct Eratosthenes {\n    std::vector<bool> is_prime;\n    std::vector<int> primes;\n    Eratosthenes(int n) {\n        is_prime.assign(n, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i < n; i++) {\n            if (!is_prime[i]) continue;\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n        for (int i = 2; i < n; i++) {\n            if (is_prime[i]) primes.push_back(i);\n        }\n    }\n};\n",
        "description": "Eratosthenes"
    },
    "MatrixStatic.hpp": {
        "prefix": "MatrixStatic",
        "body": "template <class T, int size> struct Matrix {\n    std::array<std::array<T, size>, size> A;\n    Matrix() {}\n    Matrix(const std::array<std::array<T, size>, size> &A_) : A(A_) {}\n    static Matrix eye() {\n        Matrix mat{};\n        for (int i = 0; i < size; i++) mat[i][i] = 1;\n        return mat;\n    }\n    std::array<T, size> &operator[](int k) { return A[k]; }\n    const std::array<T, size> &operator[](int k) const { return (A[k]); }\n    Matrix &operator+=(const Matrix &B) {\n        for (int i = 0; i < A.size(); i++)\n            for (int j = 0; j < A[0].size(); j++) A[i][j] += B[i][j];\n        return *this;\n    }\n    Matrix &operator-=(const Matrix &B) {\n        for (int i = 0; i < A.size(); i++)\n            for (int j = 0; j < A[0].size(); j++) A[i][j] -= B[i][j];\n        return *this;\n    }\n    Matrix &operator*=(const Matrix &B) {\n        std::array<std::array<T, size>, size> C{};\n        for (int i = 0; i < size; i++)\n            for (int j = 0; j < size; j++)\n                for (int k = 0; k < size; k++) C[i][j] += A[i][k] * B[k][j];\n        std::swap(A, C);\n        return *this;\n    }\n    Matrix operator+(const Matrix &B) const { return Matrix(*this) += B; }\n    Matrix operator-(const Matrix &B) const { return Matrix(*this) -= B; }\n    Matrix operator*(const Matrix &B) const { return Matrix(*this) *= B; }\n    std::array<T, size> operator*(const std::array<T, size> &x) const {\n        std::array<T, size> ret{};\n        for (int i = 0; i < size; i++)\n            for (int j = 0; j < size; j++) ret[i] += A[i][j] * x[j];\n        return ret;\n    }\n};\n",
        "description": "MatrixStatic"
    },
    "Matrix.hpp": {
        "prefix": "Matrix",
        "body": "template <class T> struct Matrix {\n    std::vector<std::vector<T>> A;\n    Matrix() {}\n    Matrix(int n) : A(n, std::vector<T>(n, 0)) {}\n    Matrix(const std::vector<std::vector<T>> &A_) : A(A_) {}\n    static Matrix eye(int n) {\n        Matrix mat(n);\n        for (int i = 0; i < n; i++) mat[i][i] = 1;\n        return mat;\n    }\n    int height() const { return (A.size()); }\n    int width() const { return (A[0].size()); }\n    std::vector<T> &operator[](int k) { return A[k]; }\n    const std::vector<T> &operator[](int k) const { return (A[k]); }\n    Matrix &operator+=(const Matrix &B) {\n        assert(A.size() == B.A.size() && A[0].size() == B.A[0].size());\n        for (int i = 0; i < A.size(); i++)\n            for (int j = 0; j < A[0].size(); j++) A[i][j] += B[i][j];\n        return *this;\n    }\n    Matrix &operator-=(const Matrix &B) {\n        assert(A.size() == B.A.size() && A[0].size() == B.A[0].size());\n        for (int i = 0; i < A.size(); i++)\n            for (int j = 0; j < A[0].size(); j++) A[i][j] -= B[i][j];\n        return *this;\n    }\n    Matrix &operator*=(const Matrix &B) {\n        int n = height(), m = B.width(), p = width();\n        assert(p == B.height());\n        std::vector<std::vector<T>> C(n, std::vector<T>(m, 0));\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                for (int k = 0; k < p; k++) C[i][j] += A[i][k] * B[k][j];\n        std::swap(A, C);\n        return *this;\n    }\n    Matrix operator+(const Matrix &B) const { return Matrix(*this) += B; }\n    Matrix operator-(const Matrix &B) const { return Matrix(*this) -= B; }\n    Matrix operator*(const Matrix &B) const { return Matrix(*this) *= B; }\n    std::vector<T> operator*(const std::vector<T> &x) const {\n        int n = height(), m = width();\n        assert(m == x.size());\n        std::vector<T> ret(n);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) ret[i] += A[i][j] * x[j];\n        return ret;\n    }\n};\n",
        "description": "Matrix"
    },
    "PascalTriangle.hpp": {
        "prefix": "PascalTriangle",
        "body": "/// @docs src/Math/PascalTriangle.md\ntemplate <class T = long long> struct PascalTriangle {\n    std::vector<std::vector<T>> binom;\n    PascalTriangle(int n) : binom(n + 1, std::vector<T>(n + 1)) {\n        for (int i = 0; i < n + 1; i++) {\n            binom[i][0] = 1;\n            for (int j = 1; j < i + 1; j++) {\n                binom[i][j] = binom[i - 1][j - 1] + binom[i - 1][j];\n            }\n        }\n    }\n    // nCr\n    T operator()(int n, int r) {\n        assert(0 <= n && 0 <= r && r <= n && n <= binom.size());\n        return binom[n][r];\n    }\n};",
        "description": "PascalTriangle"
    },
    "Combination.hpp": {
        "prefix": "Combination",
        "body": "template <class T> struct Combination {\n    std::vector<T> fact, fact_inv;\n    Combination(int n = 1000003) : fact(n + 1, 1), fact_inv(n + 1) {\n        for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n        fact_inv[n] = (T)1 / fact[n];\n        for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n        // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n    }\n    T operator()(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n};\n",
        "description": "Combination"
    },
    "SparseTable.hpp": {
        "prefix": "SparseTable",
        "body": "/// @docs src/DataStructure/SparseTable.md\ntemplate <class T, class F> struct SparseTable {\n    const F op;\n    std::vector<std::vector<T>> t;\n    SparseTable(F op_, const std::vector<T>& a) : op(op_), t({a}) {\n        for (int k = 1; 1 << k < a.size() + 1; k++) {\n            t.emplace_back(a.size() - (1 << k) + 1);\n            for (int i = 0; i < a.size() - (1 << k) + 1; i++) {\n                t[k][i] = op(t[k - 1][i], t[k - 1][i + (1 << (k - 1))]);\n            }\n        }\n    }\n    T query(int l, int r) const {\n        assert(0 <= l && l < r && r <= t[0].size());\n        int k = std::__lg(r - l);\n        return op(t[k][l], t[k][r - (1 << k)]);\n    }\n};\ntemplate <class T, class F> auto make_sparse_table(F op, const std::vector<T>& a) { return SparseTable<T, F>(op, a); }",
        "description": "SparseTable"
    },
    "QuickFind.hpp": {
        "prefix": "QuickFind",
        "body": "/// @docs src/DataStructure/QuickFind.md\nstruct QuickFind {\n    std::vector<int> belong_to;\n    std::vector<std::vector<int>> groups;\n    QuickFind(int n) : belong_to(n), groups(n, std::vector<int>(1)) {\n        std::iota(belong_to.begin(), belong_to.end(), 0);\n        for (int i = 0; i < n; i++) groups[i][0] = i;\n    }\n    void unite(int x, int y) {\n        x = belong_to[x], y = belong_to[y];\n        if (x == y) return;\n        if (groups[x].size() < groups[y].size()) std::swap(x, y);\n        // yをxにマージ\n        for (int v : groups[y]) belong_to[v] = x;\n        groups[x].insert(groups[x].end(), groups[y].begin(), groups[y].end());\n        groups[y].clear();\n    }\n    bool is_same(int x, int y) { return belong_to[x] == belong_to[y]; }\n};\n",
        "description": "QuickFind"
    },
    "UnionFind.hpp": {
        "prefix": "UnionFind",
        "body": "struct UnionFind {\n    int cnt;                  // 集合の数\n    std::vector<int> number;  // 0以上のとき親のindex, 負のときは集合サイズ\n    UnionFind(int n) : cnt(n), number(n, -1) {}\n    int root(int x) { return number[x] < 0 ? x : number[x] = root(number[x]); }\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x == y) return;\n        if (number[y] < number[x]) std::swap(x, y);\n        // yをxにマージ\n        number[x] += number[y];\n        number[y] = x;\n        cnt--;\n    }\n    bool is_same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -number[root(x)]; }\n};\n",
        "description": "UnionFind"
    },
    "SlidingWindowAggregation.hpp": {
        "prefix": "SlidingWindowAggregation",
        "body": "/// @docs src/DataStructure/SlidingWindowAggregation.md\ntemplate <class T, class F> struct SlidingWindowAggregation {\n    const F op;\n    const T e;\n    std::stack<std::pair<T, T>> st1, st2;  // それぞれ、{val, acc}を要素に持つような前方向と後ろ方向のstack\n    SlidingWindowAggregation(F op_, T e_) : op(op_), e(e_) { st1.emplace(e, e), st2.emplace(e, e); }\n    int size() { return st1.size() + st2.size() - 2; }\n    void push(T x) {\n        T acc = op(st2.top().second, x);\n        st2.emplace(x, acc);\n    }\n    void pop() {\n        assert(st1.size() > 1 || st2.size() > 1);\n        if (st1.size() > 1) {\n            st1.pop();\n        } else {\n            while (st2.size() > 2) {\n                T acc = op(st1.top().second, st2.top().first);\n                st1.emplace(st2.top().first, acc);\n                st2.pop();\n            }\n            st2.pop();\n        }\n    }\n    T fold_all() { return op(st1.top().second, st2.top().second); }\n};\ntemplate <class T, class F> auto make_swag(F op, T e_) { return SlidingWindowAggregation<T, F>(op, e_); }\n",
        "description": "SlidingWindowAggregation"
    },
    "Imos2D.hpp": {
        "prefix": "Imos2D",
        "body": "/// @docs src/DataStructure/Imos2D.md\n// 0-indexed\n// t.add(i0, j0, i1, j1) -> t.run() -> t[i][j]\ntemplate <class T> struct Imos2D {\n    int n, m;\n    std::vector<std::vector<T>> t;  // 0-indexed!!, -x分のために配列の外側を1大きめに\n    Imos2D(int n_, int m_) : n(n_), m(m_), t(n_ + 1, std::vector<T>(m_ + 1)) {}\n    // i0 <= i < i1, j0 < j < j1の範囲に+x\n    void add(int i0, int j0, int i1, int j1, T x) {\n        t[i0][j0] += x, t[i1][j1] += x;\n        t[i1][j0] -= x, t[i0][j1] -= x;\n    }\n    // 2方向に累積和をとる\n    void build() {\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) t[i + 1][j] += t[i][j];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) t[i][j + 1] += t[i][j];\n    }\n    std::vector<T>& operator[](int i) { return t[i]; }\n};\n",
        "description": "Imos2D"
    },
    "Accumulate2D.hpp": {
        "prefix": "Accumulate2D",
        "body": "// インターフェイスは0-indexed\n// update(i, j, x) -> run() -> query(i0, j0, i1, j1)\ntemplate <class T> struct Accumulate2D {\n    int n, m;\n    std::vector<std::vector<T>> t;  // 1-indexed!!\n    Accumulate2D(int n_, int m_) : n(n_), m(m_), t(n_ + 1, std::vector<T>(m_ + 1)) {}\n    void update(int i, int j, T x) { t[i + 1][j + 1] = x; }\n    // 累積和を取る\n    void run() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                t[i + 1][j + 1] += t[i][j + 1] + t[i + 1][j] - t[i][j];\n            }\n        }\n    }\n    // i0 <= i < i1, j0 < j < j1の範囲のsum\n    T query(int i0, int j0, int i1, int j1) { return t[i1][j1] - t[i1][j0] - t[i0][j1] + t[i0][j0]; }\n    // もともとの値\n    T query(int i, int j) { return query(i, j, i + 1, j + 1); }\n};\n",
        "description": "Accumulate2D"
    },
    "UnionFindWithData.hpp": {
        "prefix": "UnionFindWithData",
        "body": "struct UnionFind {\n    int cnt;                  // 集合の数\n    std::vector<int> number;  // 0以上のとき親のindex, 負のときは集合サイズ\n    UnionFind(int n) : cnt(n), number(n, -1) {}\n    int root(int x) { return number[x] < 0 ? x : number[x] = root(number[x]); }\n    template <class F> void unite(int x, int y, F merge) {  // merge(x, y): yをxにマージ\n        x = root(x), y = root(y);\n        if (x == y) return;\n        if (number[y] < number[x]) std::swap(x, y);\n        // yをxにマージ\n        number[x] += number[y];\n        number[y] = x;\n        cnt--;\n        merge(x, y);\n    }\n    bool is_same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -number[root(x)]; }\n};\n",
        "description": "UnionFindWithData"
    },
    "Doubling.hpp": {
        "prefix": "Doubling",
        "body": "struct Doubling {\n    int n;\n    int size;                            // MSB + 1\n    std::vector<std::vector<int>> next;  // next[k][i]: iから(1<<k)回でどこまで進めるか\n\n    // edge[i]: 1回でiからどこまで進めるか\n    Doubling(std::vector<int>& edge) : n(edge.size()), size(64 - __builtin_clzll(edge.size())) {\n        next.resize(size, std::vector<int>(n + 1, n));\n        for (int i = 0; i < n; i++) next[0][i] = edge[i];\n        for (int k = 0; k < size - 1; k++) {\n            for (int i = 0; i < n; i++) {\n                next[k + 1][i] = next[k][next[k][i]];\n            }\n        }\n    }\n    // i番目のx個先\n    int get(int i, int x) {\n        int ret = i;\n        for (int bit = 0; bit < size; bit++) {\n            if (!(x >> bit & 1)) continue;\n            ret = next[bit][ret];\n        }\n        return ret;\n    }\n    // iからはじめて何回進めば初めてj以上になるか\n    // j以上になりえないときはnを返す\n    int lower_bound(int i, int j) {\n        int cur = i, acc = 0;\n        for (int wid = size - 1; wid >= 0; wid--) {\n            if (next[wid][cur] < j) {\n                acc += 1LL << wid;\n                cur = next[wid][cur];\n            }\n        }\n        return std::min(n, acc + 1);\n    }\n};\n",
        "description": "Doubling"
    },
    "LazySegmentTree.hpp": {
        "prefix": "LazySegmentTree",
        "body": "/// @docs src/DataStructure/LazySegmentTree.md\ntemplate <class T0, class T1, class F0, class F1, class G, class P> class LazySegmentTree {\n    // k番目のノードにのlazyを伝搬\n    void eval(int k, int len) {\n        // 定数倍高速化\n        if (lazy[k] == u1) return;\n        // len個分のlazy[k]を評価\n        node[k] = g(node[k], p(lazy[k], len));\n        if (k < N - 1) {\n            // 最下段でなければ下のlazyに伝搬\n            lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n        }\n        lazy[k] = u1;\n    }\n    // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n    void update(int a, int b, T1 x, int k, int l, int r) {\n        eval(k, r - l);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = f1(lazy[k], x);\n            eval(k, r - l);\n        } else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    // k番目のノード[l, r)について、[a, b)のクエリを求める\n    T0 query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return u0;\n        eval(k, r - l);\n        if (a <= l && r <= b) return node[k];\n        T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return f0(vl, vr);\n    }\n\npublic:\n    int sz;  // 元の配列のサイズ\n    int N;\n    std::vector<T0> node;\n    std::vector<T1> lazy;\n    // T0上の演算、単位元\n    const F0 f0;\n    const T0 u0;\n    // T1上の演算、単位元\n    const F1 f1;\n    const T1 u1;\n    // T0に対するT1の作用\n    const G g;\n    // 多数のt1(T1)に対するf1の合成\n    const P p;\n\n    LazySegmentTree(F0 f0_, T0 u0_, F1 f1_, T1 u1_, G g_, P p_) : f0(f0_), u0(u0_), f1(f1_), u1(u1_), g(g_), p(p_) {}\n    void set_by_vector(const std::vector<T0>& a) {\n        sz = a.size();\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n        for (int i = 0; i < sz; i++) node[N - 1 + i] = a[i];\n        for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n    }\n    void set_by_unit(int n) {\n        sz = n;\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n    }\n    // [a, b)にxを作用\n    void update(int a, int b, T1 x) {\n        assert(0 <= a && a < b && b <= sz);\n        update(a, b, x, 0, 0, N);\n    }\n    void update(int a, T1 x) { update(a, a + 1, x); }\n    // [a, b)\n    T0 query(int a, int b) { return query(a, b, 0, 0, N); }\n    T0 query(int a) { return query(a, a + 1); }\n    friend std::string to_string(LazySegmentTree<T0, T1, F0, F1, G, P>& seg) {\n        for (int i = 0; i < seg.sz; i++) seg.query(i);\n        return to_string(std::vector<T0>(seg.node.begin() + (seg.N - 1), seg.node.begin() + (seg.N - 1 + seg.sz)));\n    }\n};\ntemplate <class T0, class T1, class F0, class F1, class G, class P>\nauto make_lazy_segment_tree(F0 f0, T0 u0, F1 f1, T1 u1, G g, P p) {\n    return LazySegmentTree<T0, T1, F0, F1, G, P>(f0, u0, f1, u1, g, p);\n}\n",
        "description": "LazySegmentTree"
    },
    "SegmentTree.hpp": {
        "prefix": "SegmentTree",
        "body": "/// @docs src/DataStructure/SegmentTree.md\ntemplate <class T, class F> struct SegmentTree {\n    const F op;\n    const T e;\n    SegmentTree(F op_, T e_) : op(op_), e(e_) {}\n    int n;\n    std::vector<T> t;\n    void set_by_identity(int n_) {\n        n = n_;\n        t.clear(), t.resize(2 * n, e);\n    }\n    void set_by_vector(const std::vector<T>& a) {\n        n = a.size();\n        t.clear(), t.resize(2 * n, e);\n        for (int i = 0; i < n; i++) t[i + n] = a[i];\n        build();\n    }\n    void build() {\n        for (int i = n - 1; i; --i) t[i] = op(t[2 * i], t[2 * i + 1]);\n    }\n    T& operator[](int i) { return t[i + n]; }\n    // [l, r)\n    T query(int l, int r) const {\n        assert(0 <= l && l <= r && r <= n);\n        T resl = e, resr = e;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) resl = op(resl, t[l++]);\n            if (r & 1) resr = op(t[--r], resr);\n        }\n        return op(resl, resr);\n    }\n    // i番目をxに変更\n    void update(int i, const T& x) {\n        assert(0 <= i && i < n);\n        t[i += n] = x;\n        while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n    }\n    // i番目にxを作用 (a[i] = op(a[i], x))\n    void operate(int i, const T& x) {\n        assert(0 <= i && i < n);\n        i += n;\n        t[i] = op(t[i], x);\n        while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n    }\n    friend std::string to_string(const SegmentTree<T, F>& seg) {\n        return to_string(std::vector<T>(seg.t.begin() + seg.n, seg.t.end()));\n    }\n};\ntemplate <class T, class F> auto make_segment_tree(F op, T e) { return SegmentTree<T, F>(op, e); }\n",
        "description": "SegmentTree"
    },
    "MoAlgorithm.hpp": {
        "prefix": "MoAlgorithm",
        "body": "/// @docs src/DataStructure/MoAlgorithm.md\nstruct Mo {\n    struct Query {\n        int l, r, idx;  // 配列に対する[l, r)のクエリ, idxはクエリの番号\n        Query(int l_, int r_, int idx_) : l(l_), r(r_), idx(idx_) {}\n    };\n    int width;\n    std::vector<Query> query;\n    std::vector<bool> v;\n\n    // widthは指定しないと自動でsqrt(n)にする\n    Mo(int n, int width_ = -1) : width(width_ == -1 ? (int)sqrt(n) : width_), v(n) {}\n    void add(int l, int r) {\n        int idx = query.size();\n        query.emplace_back(l, r, idx);\n    }\n    template <class F, class G, class H> void run(const F& add, const G& del, const H& rem) {\n        std::sort(query.begin(), query.end(), [&](const Query& a, const Query& b) {\n            int ablock = a.l / width, bblock = b.l / width;\n            if (ablock != bblock) return ablock < bblock;\n            if (ablock & 1) return a.r < b.r;\n            return a.r > b.r;\n        });\n        int nl = 0, nr = 0;\n        auto push = [&](int idx) {\n            v[idx].flip();\n            if (v[idx])\n                add(idx);\n            else\n                del(idx);\n        };\n        for (Query& q : query) {\n            while (nl > q.l) push(--nl);\n            while (nr < q.r) push(nr++);\n            while (nl < q.l) push(nl++);\n            while (nr > q.r) push(--nr);\n            rem(q.idx);\n            while (nl > q.l) push(--nl);\n        }\n    }\n};\n",
        "description": "MoAlgorithm"
    },
    "WaveletMatrix.hpp": {
        "prefix": "WaveletMatrix",
        "body": "int popcount(std::uint32_t x) { return __builtin_popcount(x); }\nint popcount(std::uint64_t x) { return __builtin_popcountll(x); }\n\ntemplate <class block_type = std::uint64_t> struct BitVector {\n    static constexpr size_t b = sizeof(block_type) * CHAR_BIT;  // blockのサイズ\n    int n;\n    std::vector<block_type> bit;\n    std::vector<int> acc;\n    BitVector() {}\n    BitVector(int n_) : n(n_), bit(n / b + 1), acc(n / b + 1) {}\n    template <bool x = 1> void set(size_t i) {\n        if (x)\n            bit[i / b] |= (block_type)1 << (i % b);\n        else\n            bit[i / b] &= ~((block_type)1 << (i % b));\n    }\n    void build() {\n        for (int i = 0; i < (int)acc.size() - 1; i++) {\n            acc[i + 1] = acc[i] + popcount(bit[i]);\n        }\n    }\n    // [0, i)内のxの個数\n    template <bool x> int rank(size_t i) {\n        if (x)\n            return acc[i / b] + (i % b ? popcount(bit[i / b] << (b - i % b)) : 0);\n        else\n            return i - rank<1>(i);\n    }\n    // j番目のxのindex\n    template <bool x> int select(size_t j) {\n        int ok = n, ng = -1;\n        while (std::abs(ok - ng) > 1) {\n            int mid = (ok + ng) / 2;\n            (rank<x>(mid + 1) > j ? ok : ng) = mid;\n        }\n        return ok;\n    }\n};\n\ntemplate <class T, int maxlog = 31, class block_type = std::uint64_t> struct WaveletMatrix {\n    static_assert((T(1) << (maxlog - 1)) > 0);\n    using bv_type = BitVector<block_type>;\n    std::array<bv_type, maxlog> bvs;      // [maxlog, n]の01行列\n    std::array<int, maxlog> offset = {};  // 各列でbitが0になっている要素の数\n\n    WaveletMatrix(const std::vector<T>& a) {\n        std::vector<T> cur_data = a;\n        for (int k = maxlog - 1; k >= 0; k--) {  // 上位bitから見る\n            std::vector<T> zero, one;\n            bvs[k] = bv_type(a.size());\n            for (int i = 0; i < a.size(); i++) {\n                bool bit = cur_data[i] >> k & 1;\n                if (bit)\n                    one.push_back(cur_data[i]), bvs[k].template set<1>(i);\n                else\n                    zero.push_back(cur_data[i]);\n            }\n            offset[k] = zero.size();\n            cur_data = std::move(zero);\n            cur_data.insert(cur_data.end(), one.begin(), one.end());\n            bvs[k].build();\n        }\n    }\n    // [l, r)の{x未満の個数, xの個数, xより大の個数}\n    std::array<int, 3> rank_3way(int l, int r, int x) {\n        int lt = 0, eq = r - l, gt = 0;\n        for (int k = maxlog - 1; k >= 0; k--) {\n            int prv_num = r - l;\n            if (x >> k & 1) {\n                l = offset[k] + bvs[k].template rank<1>(l);\n                r = offset[k] + bvs[k].template rank<1>(r);\n                lt += prv_num - (r - l);\n            } else {\n                l = bvs[k].template rank<0>(l);\n                r = bvs[k].template rank<0>(r);\n                gt += prv_num - (r - l);\n            }\n            eq -= prv_num - (r - l);\n        }\n        return {lt, eq, gt};\n    }\n    // [l, r)内の(小さい方から)j番目(0-index)の数\n    int quantile(int l, int r, int j) {\n        assert(j < r - l);\n        T ret = 0;\n        for (int k = maxlog - 1; k >= 0; k--) {\n            int zl = bvs[k].template rank<0>(l);\n            int zr = bvs[k].template rank<0>(r);\n            if (zr - zl > j) {  // kビット目は0\n                l = zl;\n                r = zr;\n            } else {  // kビット目は1\n                l = offset[k] + (l - zl);\n                r = offset[k] + (r - zr);\n                ret |= (T)1 << k;\n                j -= zr - zl;\n            }\n        }\n        return ret;\n    }\n};\n",
        "description": "WaveletMatrix"
    },
    "DynamicUnionFind.hpp": {
        "prefix": "DynamicUnionFind",
        "body": "struct DynamicUnionFind {\n    int cnt = 0;\n    std::unordered_map<int, int> number;\n\n    int root(int x) {\n        if (!number.count(x)) number[x] = -1, cnt++;\n        return number[x] < 0 ? x : number[x] = root(number[x]);\n    }\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x == y) return;\n        if (number[y] < number[x]) std::swap(x, y);\n        // yをxにマージ\n        number[x] += number[y];\n        number[y] = x;\n        cnt--;\n    }\n    bool is_same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -number[root(x)]; }\n};\n",
        "description": "DynamicUnionFind"
    },
    "LazySegmentTreeACL.hpp": {
        "prefix": "LazySegmentTreeACL",
        "body": "#include <algorithm>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S), F (*composition)(F, F), F (*id)()>\nstruct lazy_segtree {\npublic:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\nprivate:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\nnamespace min_update {\nusing T = Int;\n\nusing S = T;\nS op(S x, S y) { return std::min<S>(x, y); }\nS e() { return std::numeric_limits<S>::max(); }\nusing F = T;\nconstexpr F dummy = std::numeric_limits<F>::min();\nS mapping(F f, S x) { return f == dummy ? x : f; }\nF composition(F f, F g) { return f == dummy ? g : f; }\nF id() { return dummy; }\nusing segtree = atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;\n};  // namespace min_update\n\nnamespace sum_add {\nusing T = Int;\n\nstruct S {\n    T sum;\n    int len;\n};\nS op(S x, S y) { return {x.sum + y.sum, x.len + y.len}; }\nS e() { return {0, 0}; }\nusing F = T;\nS mapping(F f, S x) { return {x.sum + f * x.len, x.len}; }\nF composition(F f, F g) { return f + g; }\nF id() { return 0; }\nusing segtree = atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;\n}  // namespace sum_add\n\nnamespace min_add {\nusing T = Int;\n\nusing S = T;\nS op(S x, S y) { return std::min(x, y); }\nS e() { return std::numeric_limits<S>::max() / 2; }\nusing F = T;\nS mapping(F f, S x) { return x + f; }\nF composition(F f, F g) { return f + g; }\nF id() { return 0; }\nusing segtree = atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;\n}  // namespace min_add\n\nnamespace sum_update {\nusing T = Int;\n\nstruct S {\n    T sum;\n    int len;\n};\nS op(S x, S y) { return {x.sum + y.sum, x.len + y.len}; }\nS e() { return {0, 0}; }\nusing F = T;\nconstexpr F dummy = std::numeric_limits<F>::min();\nS mapping(F f, S x) { return f == dummy ? x : S{f * x.len, x.len}; }\nF composition(F f, F g) { return f == dummy ? g : f; }\nF id() { return dummy; }\nusing segtree = atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;\n}  // namespace sum_update\n",
        "description": "LazySegmentTreeACL"
    },
    "ZAlgorithm.hpp": {
        "prefix": "ZAlgorithm",
        "body": "/// @docs src/String/ZAlgorithm.md\ntemplate <class T> std::vector<int> Z_algorithm(const T& s) {\n    std::vector<int> a(s.size());\n    for (int i = 1, rm_idx = 0; i < s.size(); i++) {\n        if (a[i - rm_idx] < a[rm_idx] - (i - rm_idx)) {\n            a[i] = a[i - rm_idx];\n        } else {\n            a[i] = std::max(0, a[rm_idx] - (i - rm_idx));\n            while (i + a[i] < s.size() && s[a[i]] == s[i + a[i]]) a[i]++;\n            rm_idx = i;\n        }\n    }\n    a[0] = s.size();\n    return a;\n}\n",
        "description": "ZAlgorithm"
    },
    "RollingHash.hpp": {
        "prefix": "RollingHash",
        "body": "/// @docs src/String/RollingHash.md\ntemplate <class T> struct RollingHash {\n    std::vector<int> hash, pows;\n    int base, mod;\n    RollingHash(const T &a, int base_, int mod_ = 1000000009)\n        : hash(a.size() + 1), pows(a.size() + 1, 1), base(base_), mod(mod_) {\n        for (int i = 0; i < a.size(); i++) {\n            pows[i + 1] = (long long)pows[i] * base % mod;\n            hash[i + 1] = ((long long)hash[i] * base % mod + a[i]) % mod;\n            if (hash[i + 1] < 0) hash[i + 1] += mod;\n        }\n    }\n    // 現在の文字列のサイズ\n    int size() { return hash.size() - 1; }\n    // [l, r)\n    int get(int l, int r) {\n        assert(l <= r);\n        int ret = hash[r] + mod - (long long)hash[l] * pows[r - l] % mod;\n        if (ret >= mod) ret -= mod;\n        return ret;\n    }\n    void concat(const T &b) {\n        int n = hash.size() - 1, m = b.size();\n        pows.resize(n + m + 1);\n        hash.resize(n + m + 1);\n        for (int i = 0; i < m; i++) {\n            pows[n + i + 1] = (long long)pows[n + i] * base % mod;\n            hash[n + i + 1] = (long long)hash[n + i] * base % mod + b[i];\n            if (hash[n + i + 1] >= mod) hash[n + i + 1] -= mod;\n        }\n    }\n    void pop_back() {\n        hash.pop_back();\n        pows.pop_back();\n    }\n};\n\ntemplate <int HashNum> std::array<int, HashNum> make_rand_array() {\n    std::array<int, HashNum> res;\n    std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());\n    for (int i = 0; i < HashNum; i++) res[i] = rnd() % 1000000;\n    return res;\n}\ntemplate <class T, int HashNum = 4> struct MultiRollingHash {\n    using multihash_t = std::array<int, HashNum>;\n    static std::array<int, HashNum> bases;\n    std::vector<RollingHash<T>> rhs;\n    MultiRollingHash(const T &a) {\n        for (int i = 0; i < HashNum; i++) {\n            rhs.push_back(RollingHash<T>(a, bases[i]));\n        }\n    }\n    multihash_t get(int l, int r) {\n        multihash_t ret;\n        for (int i = 0; i < HashNum; i++) ret[i] = rhs[i].get(l, r);\n        return ret;\n    }\n    int size() { return rhs[0].size(); }\n    void concat(const T &b) {\n        for (auto &rh : rhs) rh.concat(b);\n    }\n    void pop_back() {\n        for (auto &rh : rhs) rh.pop_back();\n    }\n};\ntemplate <class T, int HashNum>\nstd::array<int, HashNum> MultiRollingHash<T, HashNum>::bases = make_rand_array<HashNum>();\n",
        "description": "RollingHash"
    },
    "Trie.hpp": {
        "prefix": "Trie",
        "body": "template <char margin = 'A', int char_size = 26> struct Trie {\n    struct TrieNode {\n        std::array<int, char_size> node;\n        TrieNode() { node.fill(-1); };\n        typename std::array<int, char_size>::iterator begin() { return node.begin(); }\n        typename std::array<int, char_size>::iterator end() { return node.end(); }\n        int& operator[](int i) { return node[i]; }\n    };\n    std::vector<TrieNode> tree;\n    std::vector<int> num;  // 部分木内の個数\n    Trie() : tree(1), num(1) {}\n    void insert(const std::string& s) {\n        num[0]++;\n        int t = 0;\n        for (char c : s) {\n            int d = c - margin;\n            if (tree[t][d] == -1) {\n                tree[t][d] = tree.size();\n                tree.emplace_back();\n                num.push_back(0);\n            }\n            t = tree[t][d];\n            num[t]++;\n        }\n    }\n    void erase(const std::string& s) {\n        int par = 0;\n        num[par]--;\n        for (char c : s) {\n            int d = c - margin;\n            int nxt = tree[par][d];\n            assert(nxt != -1 && \"s does not exist\");\n            if (--num[nxt] == 0) tree[par][d] = -1;\n            par = nxt;\n        }\n    }\n};\n",
        "description": "Trie"
    },
    "SuffixArray.hpp": {
        "prefix": "SuffixArray",
        "body": "/// @docs src/String/SuffixArray.md\nclass SuffixArray {\n    std::vector<int> sa_is(const std::vector<int>& str, const int k) {\n        const int n = str.size();\n        std::vector<bool> is_S(n);\n        is_S[n - 1] = true;\n        std::vector<bool> is_LMS(n);\n        std::vector<int> LMSs;\n        for (int i = n - 2; i >= 0; i--) {\n            is_S[i] = str[i] < str[i + 1] || (str[i] == str[i + 1] && is_S[i + 1]);\n        }\n        for (int i = 0; i < n; i++) {\n            if (is_S[i] & (i == 0 || !is_S[i - 1])) {\n                is_LMS[i] = true;\n                LMSs.push_back(i);\n            }\n        }\n        std::vector<int> pseudo_sa = induced_sort(str, LMSs, is_S, k);\n        std::vector<int> orderedLMSs(LMSs.size());\n        int index = 0;\n        for (int x : pseudo_sa) {\n            if (is_LMS[x]) {\n                orderedLMSs[index++] = x;\n            }\n        }\n        pseudo_sa[orderedLMSs[0]] = 0;\n        int rank = 0;\n        if (orderedLMSs.size() > 1) {\n            pseudo_sa[orderedLMSs[1]] = ++rank;\n        }\n        for (int i =  1; i < orderedLMSs.size() - 1; i++) {\n            bool is_diff = false;\n            for (int j = 0; j < n; j++) {\n                int p = orderedLMSs[i] + j;\n                int q = orderedLMSs[i + 1] + j;\n                if (str[p] != str[q] || is_LMS[p] != is_LMS[q]) {\n                    is_diff = true;\n                    break;\n                }\n                if (j > 0 && is_LMS[p]) {\n                    break;\n                }\n            }\n            pseudo_sa[orderedLMSs[i + 1]] = is_diff ? ++rank : rank;\n        }\n        std::vector<int> new_str(LMSs.size());\n        index = 0;\n        for (int i = 0; i < n; i++) {\n            if (is_LMS[i]) {\n                new_str[index++] = pseudo_sa[i];\n            }\n        }\n        std::vector<int> LMS_sa;\n        if (rank + 1 == LMSs.size()) {\n            LMS_sa = orderedLMSs;\n        } else {\n            LMS_sa = sa_is(new_str, rank + 1);\n            for (int& x : LMS_sa) {\n                x = LMSs[x];\n            }\n        }\n        return induced_sort(str, LMS_sa, is_S, k);\n    }\n\n    std::vector<int> induced_sort(const std::vector<int>& str, const std::vector<int>& LMSs, const std::vector<bool>& is_S, const int k) {\n        int n = str.size();\n        std::vector<int> buckets(n);\n        std::vector<int> chars(k + 1);\n        for (int c : str) {\n            chars[c + 1]++;\n        }\n        for (int i = 0; i < k; i++) { chars[i + 1] += chars[i]; }\n        std::vector<int> count(k);\n        for (int i = LMSs.size() - 1; i >= 0; i--) {\n            int c = str[LMSs[i]];\n            buckets[chars[c + 1] - 1 - count[c]++] = LMSs[i];\n        }\n        count = std::vector<int>(k);\n        for (int i = 0; i < n; i++) {\n            if (buckets[i] == 0 || is_S[buckets[i] - 1]) {\n                continue;\n            }\n            int c = str[buckets[i] - 1];\n            buckets[chars[c] + count[c]++] = buckets[i] - 1;\n        }\n        count = std::vector<int>(k);\n        for (int i = n - 1; i >= 0; i--) {\n            if (buckets[i] == 0 || !is_S[buckets[i] - 1]) {\n                continue;\n            }\n            int c = str[buckets[i] - 1];\n            buckets[chars[c + 1] - 1 - count[c]++] = buckets[i] - 1;\n        }\n        return buckets;\n    }\n\npublic:\n    std::string S;\n    int N;\n    std::vector<int> sa;  // sa[i]: suffixが辞書順i番目となる開始位置のindex\n    SuffixArray(std::string str_in) : S(str_in), N(str_in.size()) {\n        str_in += \"$\";\n        std::vector<int> str(N + 1);\n        for (int i = 0; i < N + 1; i++) { str[i] = str_in[i] - '$'; }\n        sa = sa_is(str, 128);\n        sa.erase(sa.begin());\n    }\n    int operator[](int index) { return sa[index]; }\n\n    // sizeがTと等しく初めてT以上になるようなSの部分文字列(sa)\n    std::vector<int>::iterator lower_bound(std::string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sa[mid], T.size(), T) < 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sa.begin() + r;\n    }\n\n    // sizeがTと等しく初めてTより大きくなるようなSの部分文字列(sa)\n    std::vector<int>::iterator upper_bound(std::string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sa[mid], T.size(), T) <= 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sa.begin() + r;\n    }\n\n    // S2が部分文字列として何回出現するか\n    int count(std::string S2) { return upper_bound(S2) - lower_bound(S2); }\n};\n",
        "description": "SuffixArray"
    },
    "Manacher.hpp": {
        "prefix": "Manacher",
        "body": "template <class T> vector<int> manacher(const vector<T>& s) {\n    vector<int> R(s.size());\n    int i = 0, j = 0;\n    while (i < s.size()) {\n        while (i - j >= 0 && i + j < s.size() && s[i - j] == s[i + j]) ++j;\n        R[i] = j;\n        int k = 1;\n        while (i - k >= 0 && i + k < s.size() && k + R[i - k] < j) R[i + k] = R[i - k], ++k;\n        i += k;\n        j -= k;\n    }\n    return R;\n}\n\nstruct Manacher {\n    vector<int> a;\n    template <class T> Manacher(const vector<T>& s, T DUMMY = -1) {\n        int m = s.size() * 2 - 1;\n        vector<T> t(m, DUMMY);\n        for (int i = 0; i < s.size(); i++) {\n            t[i * 2] = s[i];\n        }\n        a = manacher(t);\n    }\n    Manacher(const string& s, char DUMMY = '$') {\n        int m = s.size() * 2 - 1;\n        vector<char> t(m, DUMMY);\n        for (int i = 0; i < s.size(); i++) {\n            t[i * 2] = s[i];\n        }\n        a = manacher(t);\n    }\n\n    // [l, r)が回文かどうか\n    bool is_palindrome(int l, int r) { return a[l + r - 1] >= r - l; }\n};\n",
        "description": "Manacher"
    },
    "TreeDFS.hpp": {
        "prefix": "TreeDFS",
        "body": "auto dfs = [&](auto&& self, int v, int prv) -> void {\n    for (int s : g[v]) {\n        if (s == prv) continue;\n        self(self, s, v);\n    }\n};\ndfs(dfs, 0, -1);\n",
        "description": "TreeDFS"
    },
    "Directions.hpp": {
        "prefix": "Directions",
        "body": "const std::vector<std::pair<int, int>> DIRECTIONS = {\n    {1, 0}, {0, 1},  {-1, 0},  {0, -1},  // 4方向\n    {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n    {0, 0},                              // 自身\n};\n",
        "description": "Directions"
    },
    "RotateReflect2D.hpp": {
        "prefix": "RotateReflect2D",
        "body": "template <class T> std::vector<std::vector<T>> rotate_2D(const std::vector<std::vector<T>>& t, bool counterclockwise = true) {\n    int H = t.size(), W = t[0].size();\n    std::vector<std::vector<T>> ret(W, std::vector<T>(H));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            ret[j][i] = counterclockwise ? t[i][W - 1 - j] : t[H - 1 - i][j];\n        }\n    }\n    return ret;\n}\n\ntemplate <class T> std::vector<std::vector<T>> reflect_2D(const std::vector<std::vector<T>>& t) {\n    int H = t.size(), W = t[0].size();\n    std::vector<std::vector<T>> ret(W, std::vector<T>(H));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            ret[j][i] = t[i][j];\n        }\n    }\n    return ret;\n}\n",
        "description": "RotateReflect2D"
    },
    "BinarySearch.hpp": {
        "prefix": "BinarySearch",
        "body": "/// @docs src/Helper/BinarySearch.md\ntemplate <class F> long long binary_search(long long ok, long long ng, F check) {\n    while (std::abs(ok - ng) > 1) {\n        long long mid = (ok + ng) / 2;\n        (check(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n",
        "description": "BinarySearch"
    },
    "TernarySearch.hpp": {
        "prefix": "TernarySearch",
        "body": "/// @docs src/Helper/TernarySearch.md\ntemplate <class F, class T = long long> T ternary_search(T l, T r, F f, bool is_max = true) {\n    auto g = [&f, &is_max](T x) { return is_max ? f(x) : -f(x); };\n    while (std::abs(l - r) > 2) {\n        T m1 = (2 * l + r) / 3, m2 = (l + 2 * r) / 3;\n        if (g(m1) < g(m2))\n            l = m1;\n        else\n            r = m2;\n    }\n    // 極値のindexは[l, r)の範囲で、abs(l - r) <= 2になっている\n    if (l + 1 < r && g(l + 1) > g(l)) l = l + 1;\n    return l;\n}\n",
        "description": "TernarySearch"
    },
    "RunLengthEncode.hpp": {
        "prefix": "RunLengthEncode",
        "body": "template <class T> std::vector<std::pair<T, int>> run_length_encode(const std::vector<T>& a) {\n    std::vector<std::pair<T, int>> ret;\n    int cur = 0;\n    for (int i = 0; i < a.size(); i++) {\n        cur++;\n        if (i == a.size() - 1 || a[i] != a[i + 1]) {\n            ret.emplace_back(a[i], cur);\n            cur = 0;\n        }\n    }\n    return ret;\n}\nstd::vector<std::pair<char, int>> run_length_encode(const std::string& a) {\n    std::vector<std::pair<char, int>> ret;\n    int cur = 0;\n    for (int i = 0; i < a.size(); i++) {\n        cur++;\n        if (i == a.size() - 1 || a[i] != a[i + 1]) {\n            ret.emplace_back(a[i], cur);\n            cur = 0;\n        }\n    }\n    return ret;\n}\n",
        "description": "RunLengthEncode"
    },
    "Random.hpp": {
        "prefix": "Random",
        "body": "std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());\n",
        "description": "Random"
    },
    "TreeInput.hpp": {
        "prefix": "TreeInput",
        "body": "int n;\nstd::cin >> n;\nstd::vector<std::vector<int>> g(n);\nfor (int i = 0; i < n - 1; i++) {\n    int u, v;\n    std::cin >> u >> v;\n    u--, v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n}\n",
        "description": "TreeInput"
    },
    "PairOperations.hpp": {
        "prefix": "PairOperations",
        "body": "template <class A, class B, class C, class D>\nstd::pair<A, B>& operator+=(std::pair<A, B>& x, const std::pair<C, D>& y) {\n    return x = {x.first + y.first, x.second + y.second};\n}\ntemplate <class A, class B, class C, class D> std::pair<A, B> operator+(std::pair<A, B> x, const std::pair<C, D>& y) {\n    return x += y;\n}\ntemplate <class T, class integer> T& get(std::vector<std::vector<T>>& v, const std::pair<integer, integer>& p) {\n    return v[p.first][p.second];\n}\n",
        "description": "PairOperations"
    },
    "EnumerateFixedSizeSet.hpp": {
        "prefix": "EnumerateFixedSizeSet",
        "body": "// |S| = kな集合(nCk)(昇順)\nfor (long long S = (1LL << k) - 1; S < (1LL << n);\n     S = ((S | (S - 1)) + 1) | (((~(S | (S - 1)) & -~(S | (S - 1))) - 1) >> (__builtin_ctz(S) + 1))) {\n}\n",
        "description": "EnumerateFixedSizeSet"
    },
    "MakeFixPoint.hpp": {
        "prefix": "MakeFixPoint",
        "body": "/// @docs src/Helper/MakeFixPoint.md\ntemplate <typename F> struct FixPoint : F {\n    FixPoint(F&& f) : F(std::forward<F>(f)) {}\n    template <typename... Args> decltype(auto) operator()(Args&&... args) const {\n        return F::operator()(*this, std::forward<Args>(args)...);\n    }\n};\ntemplate <typename F> decltype(auto) make_fix_point(F&& f) { return FixPoint<F>{std::forward<F>(f)}; }\n",
        "description": "MakeFixPoint"
    },
    "BitOperation.hpp": {
        "prefix": "BitOperation",
        "body": "\n// Sの部分集合の列挙\nfor (int T = S;; T = (T - 1) & S) {\n    // 操作\n    if (T == 0) break;\n}\n",
        "description": "BitOperation"
    },
    "MsbLsb.hpp": {
        "prefix": "MsbLsb",
        "body": "int get_msb(long long x) {\n    assert(x != 0);\n    return 63 - __builtin_clzll(x);\n}\nint get_lsb(long long x) {\n    assert(x != 0);\n    return __builtin_ctzll(x);\n}\n",
        "description": "MsbLsb"
    },
    "ArithmeticParser.hpp": {
        "prefix": "ArithmeticParser",
        "body": "// 四則演算のParser\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n// exp1 = exp2 [ ('+'|'-') exp2 ]*\n// exp2 = exp3 [ ('*'|'/') exp3 ]*\n// exp3 = '(' exp1 ')' | number\n\nint exp1(const string& s, int& i);\nint exp2(const string& s, int& i);\nint exp3(const string& s, int& i);\nint number(const string& s, int& i);\nint exp1(const string& s, int& i) {\n    int acc = exp2(s, i);\n    while (1) {\n        if (s[i] == '+')\n            acc += exp2(s, ++i);\n        else if (s[i] == '-')\n            acc -= exp2(s, ++i);\n        else\n            return acc;\n    }\n}\nint exp2(const string& s, int& i) {\n    int acc = exp3(s, i);\n    while (1) {\n        if (s[i] == '*')\n            acc *= exp3(s, ++i);\n        else if (s[i] == '/')\n            acc /= exp3(s, ++i);\n        else\n            return acc;\n    }\n}\nint exp3(const string& s, int& i) {\n    if (s[i] == '(') {\n        int ret = exp1(s, ++i);\n        assert(s[i] == ')');\n        i++;\n        return ret;\n    }\n    return number(s, i);\n}\nint number(const string& s, int& i) {\n    int acc = 0;\n    while (isdigit(s[i])) {\n        acc = acc * 10 + (s[i++] - '0');\n    }\n    return acc;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int i = 0;\n    cout << exp1(s, i) << endl;\n    assert(s[i] == '=');\n}\nsigned main() {\n    int T;\n    cin >> T;\n    while (T--) solve();\n}\n",
        "description": "ArithmeticParser"
    },
    "Compressor.hpp": {
        "prefix": "Compressor",
        "body": "template <class T> struct Compressor {\n    std::vector<T> val;\n    void insert(T x) { val.push_back(x); }\n    void insert(const std::vector<T>& v) { val.insert(val.begin(), v.begin(), v.end()); }\n    void build() {\n        std::sort(val.begin(), val.end());\n        val.erase(std::unique(val.begin(), val.end()), val.end());\n    }\n    int operator()(T x) { return std::lower_bound(val.begin(), val.end(), x) - val.begin(); }\n    T operator[](int idx) { return val[idx]; }\n    int size() { return val.size(); }\n};\n",
        "description": "Compressor"
    },
    "MakeVec.hpp": {
        "prefix": "MakeVec",
        "body": "template <class T, class S> T make_vec(S x) { return x; }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) {\n    return std::vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...));\n}\n",
        "description": "MakeVec"
    },
    "GccTree.hpp": {
        "prefix": "GccTree",
        "body": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate <class T> using treap = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n",
        "description": "GccTree"
    },
    "ChminChmax.hpp": {
        "prefix": "ChminChmax",
        "body": "template <class T> bool chmin(T& a, const T& b) { return a > b ? a = b, true : false; }\ntemplate <class T> bool chmax(T& a, const T& b) { return a < b ? a = b, true : false; }\n",
        "description": "ChminChmax"
    },
    "FordFulkerson.hpp": {
        "prefix": "FordFulkerson",
        "body": "/// @docs src/Flow/FordFulkerson.md\ntemplate <class T = long long> struct FordFulkerson {\n    struct Edge {\n        int to, rev_idx;  // 逆辺はg[to][rev_idx]\n        T cap;\n        bool is_rev;\n    };\n    std::vector<std::vector<Edge>> g;\n    FordFulkerson(int n) : g(n) {}\n\n    void add_edge(int from, int to, T cap) {\n        g[from].push_back({to, (int)g[to].size(), cap, false});\n        g[to].push_back({from, (int)g[from].size() - 1, 0, true});\n    }\n    T max_flow(int s, int t) {\n        std::vector<bool> used(g.size());\n        auto dfs = [this, &used, &t](auto f, int v, T min_acc) -> T {\n            if (v == t) return min_acc;\n            if (used[v]) return 0;\n            used[v] = true;\n            for (Edge& e : g[v]) {\n                if (e.cap == 0) continue;\n                T dif = f(f, e.to, std::min(min_acc, e.cap));\n                if (dif == 0) continue;\n                e.cap -= dif, g[e.to][e.rev_idx].cap += dif;\n                return dif;\n            }\n            return 0;\n        };\n\n        T flow = 0;\n        while (1) {\n            std::fill(used.begin(), used.end(), false);\n            T f = dfs(dfs, s, std::numeric_limits<T>::max() / 2);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    // max_flow()の後に呼ぶと、{u, v, 流した流量}のvectorを返す\n    std::vector<std::tuple<int, int, T>> construct() {\n        std::vector<std::tuple<int, int, T>> ret;\n        for (int i = 0; i < g.size(); i++) {\n            for (Edge& e : g[i]) {\n                if (e.is_rev) continue;\n                T f = g[e.to][e.rev_idx].cap;\n                if (f == 0) continue;\n                ret.push_back({i, e.to, f});\n            }\n        }\n        return ret;\n    }\n};\n",
        "description": "FordFulkerson"
    },
    "Dinic.hpp": {
        "prefix": "Dinic",
        "body": "/// @docs src/Flow/Dinic.md\ntemplate <class T = long long> struct Dinic {\n    struct Edge {\n        int to, rev_idx;  // 逆辺はg[to][rev_idx]\n        T cap;\n        bool is_rev;\n    };\n    std::vector<std::vector<Edge>> g;\n    Dinic(int n) : g(n) {}\n\n    void add_edge(int from, int to, T cap) {\n        g[from].push_back({to, (int)g[to].size(), cap, false});\n        g[to].push_back({from, (int)g[from].size() - 1, 0, true});\n    }\n    T max_flow(int s, int t) {\n        std::vector<int> level(g.size());\n        auto bfs = [this, &level, &s, &t]() -> bool {\n            std::fill(level.begin(), level.end(), -1);\n            std::queue<int> q;\n            level[s] = 0, q.push(s);\n            while (!q.empty()) {\n                int v = q.front();\n                q.pop();\n                for (Edge& e : g[v]) {\n                    if (e.cap == 0 || level[e.to] != -1) continue;\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n            return level[t] != -1;  // 終了していなければtrueを返す\n        };\n        std::vector<int> iter(g.size());\n        auto dfs = [this, &level, &iter, &t](auto f, int v, T min_acc) -> T {\n            if (v == t) return min_acc;\n            for (int& i = iter[v]; i < g[v].size(); i++) {\n                Edge& e = g[v][i];\n                if (e.cap == 0 || level[e.to] <= level[v]) continue;\n                T dif = f(f, e.to, std::min(min_acc, e.cap));\n                if (dif == 0) continue;\n                e.cap -= dif, g[e.to][e.rev_idx].cap += dif;\n                return dif;\n            }\n            return 0;\n        };\n\n        T flow = 0;\n        while (bfs()) {\n            std::fill(iter.begin(), iter.end(), 0);\n            while (1) {\n                T f = dfs(dfs, s, std::numeric_limits<T>::max() / 2);\n                if (f == 0) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    // max_flow()の後に呼ぶと、{u, v, 流した流量}のvectorを返す\n    std::vector<std::tuple<int, int, T>> construct() {\n        std::vector<std::tuple<int, int, T>> ret;\n        for (int i = 0; i < g.size(); i++) {\n            for (Edge& e : g[i]) {\n                if (e.is_rev) continue;\n                T f = g[e.to][e.rev_idx].cap;\n                if (f == 0) continue;\n                ret.push_back({i, e.to, f});\n            }\n        }\n        return ret;\n    }\n};\n",
        "description": "Dinic"
    }
}